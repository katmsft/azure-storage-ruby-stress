#
# Auto-generated by Thrift Compiler (0.9.2)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#

require "thrift"
require_relative "cloud_blob_container_types"

module Azure::Storage::Stress
  module AutoGenerated
    module CloudBlobContainerService
      class Client
        include ::Thrift::Client

        def exists(reqInfo, accountInfo)
          send_exists(reqInfo, accountInfo)
          return recv_exists()
        end

        def send_exists(reqInfo, accountInfo)
          send_message("exists", Exists_args, reqInfo: reqInfo, accountInfo: accountInfo)
        end

        def recv_exists()
          result = receive_message(Exists_result)
          return result.success unless result.success.nil?
          raise result.storageException unless result.storageException.nil?
          raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, "exists failed: unknown result")
        end

        def fetchAttributes(reqInfo, accountInfo)
          send_fetchAttributes(reqInfo, accountInfo)
          return recv_fetchAttributes()
        end

        def send_fetchAttributes(reqInfo, accountInfo)
          send_message("fetchAttributes", FetchAttributes_args, reqInfo: reqInfo, accountInfo: accountInfo)
        end

        def recv_fetchAttributes()
          result = receive_message(FetchAttributes_result)
          return result.success unless result.success.nil?
          raise result.wse unless result.wse.nil?
          raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, "fetchAttributes failed: unknown result")
        end

        def setMetadata(reqInfo, accountInfo, metadata)
          send_setMetadata(reqInfo, accountInfo, metadata)
          return recv_setMetadata()
        end

        def send_setMetadata(reqInfo, accountInfo, metadata)
          send_message("setMetadata", SetMetadata_args, reqInfo: reqInfo, accountInfo: accountInfo, metadata: metadata)
        end

        def recv_setMetadata()
          result = receive_message(SetMetadata_result)
          return result.success unless result.success.nil?
          raise result.wse unless result.wse.nil?
          raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, "setMetadata failed: unknown result")
        end

        def createContainer(reqInfo, accountInfo, accessType, createIfNotExists, metadata)
          send_createContainer(reqInfo, accountInfo, accessType, createIfNotExists, metadata)
          return recv_createContainer()
        end

        def send_createContainer(reqInfo, accountInfo, accessType, createIfNotExists, metadata)
          send_message("createContainer", CreateContainer_args, reqInfo: reqInfo, accountInfo: accountInfo, accessType: accessType, createIfNotExists: createIfNotExists, metadata: metadata)
        end

        def recv_createContainer()
          result = receive_message(CreateContainer_result)
          return result.success unless result.success.nil?
          raise result.storageException unless result.storageException.nil?
          raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, "createContainer failed: unknown result")
        end

        def deleteContainer(reqInfo, accountInfo, deleteIfExists)
          send_deleteContainer(reqInfo, accountInfo, deleteIfExists)
          return recv_deleteContainer()
        end

        def send_deleteContainer(reqInfo, accountInfo, deleteIfExists)
          send_message("deleteContainer", DeleteContainer_args, reqInfo: reqInfo, accountInfo: accountInfo, deleteIfExists: deleteIfExists)
        end

        def recv_deleteContainer()
          result = receive_message(DeleteContainer_result)
          return result.success unless result.success.nil?
          raise result.storageException unless result.storageException.nil?
          raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, "deleteContainer failed: unknown result")
        end

        def listBlobs(listBlobsPayload, accountInfo, containerName)
          send_listBlobs(listBlobsPayload, accountInfo, containerName)
          return recv_listBlobs()
        end

        def send_listBlobs(listBlobsPayload, accountInfo, containerName)
          send_message("listBlobs", ListBlobs_args, listBlobsPayload: listBlobsPayload, accountInfo: accountInfo, containerName: containerName)
        end

        def recv_listBlobs()
          result = receive_message(ListBlobs_result)
          return result.success unless result.success.nil?
          raise result.storageException unless result.storageException.nil?
          raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, "listBlobs failed: unknown result")
        end

        def listBlobsSegmented(listBlobsPayload, accountInfo, maxResults, continuationToken, containerName)
          send_listBlobsSegmented(listBlobsPayload, accountInfo, maxResults, continuationToken, containerName)
          return recv_listBlobsSegmented()
        end

        def send_listBlobsSegmented(listBlobsPayload, accountInfo, maxResults, continuationToken, containerName)
          send_message("listBlobsSegmented", ListBlobsSegmented_args, listBlobsPayload: listBlobsPayload, accountInfo: accountInfo, maxResults: maxResults, continuationToken: continuationToken, containerName: containerName)
        end

        def recv_listBlobsSegmented()
          result = receive_message(ListBlobsSegmented_result)
          return result.success unless result.success.nil?
          raise result.storageException unless result.storageException.nil?
          raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, "listBlobsSegmented failed: unknown result")
        end

        def acquireLease(reqInfo, accountInfo, leaseTime, proposedLeaseId)
          send_acquireLease(reqInfo, accountInfo, leaseTime, proposedLeaseId)
          return recv_acquireLease()
        end

        def send_acquireLease(reqInfo, accountInfo, leaseTime, proposedLeaseId)
          send_message("acquireLease", AcquireLease_args, reqInfo: reqInfo, accountInfo: accountInfo, leaseTime: leaseTime, proposedLeaseId: proposedLeaseId)
        end

        def recv_acquireLease()
          result = receive_message(AcquireLease_result)
          return result.success unless result.success.nil?
          raise result.storageException unless result.storageException.nil?
          raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, "acquireLease failed: unknown result")
        end

        def changeLease(reqInfo, accountInfo, proposedLeaseId)
          send_changeLease(reqInfo, accountInfo, proposedLeaseId)
          return recv_changeLease()
        end

        def send_changeLease(reqInfo, accountInfo, proposedLeaseId)
          send_message("changeLease", ChangeLease_args, reqInfo: reqInfo, accountInfo: accountInfo, proposedLeaseId: proposedLeaseId)
        end

        def recv_changeLease()
          result = receive_message(ChangeLease_result)
          return result.success unless result.success.nil?
          raise result.storageException unless result.storageException.nil?
          raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, "changeLease failed: unknown result")
        end

        def breakLease(reqInfo, accountInfo, breakPeriod)
          send_breakLease(reqInfo, accountInfo, breakPeriod)
          return recv_breakLease()
        end

        def send_breakLease(reqInfo, accountInfo, breakPeriod)
          send_message("breakLease", BreakLease_args, reqInfo: reqInfo, accountInfo: accountInfo, breakPeriod: breakPeriod)
        end

        def recv_breakLease()
          result = receive_message(BreakLease_result)
          return result.success unless result.success.nil?
          raise result.storageException unless result.storageException.nil?
          raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, "breakLease failed: unknown result")
        end

        def renewLease(reqInfo, accountInfo)
          send_renewLease(reqInfo, accountInfo)
          return recv_renewLease()
        end

        def send_renewLease(reqInfo, accountInfo)
          send_message("renewLease", RenewLease_args, reqInfo: reqInfo, accountInfo: accountInfo)
        end

        def recv_renewLease()
          result = receive_message(RenewLease_result)
          return result.success unless result.success.nil?
          raise result.storageException unless result.storageException.nil?
          raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, "renewLease failed: unknown result")
        end

        def releaseLease(reqInfo, accountInfo)
          send_releaseLease(reqInfo, accountInfo)
          return recv_releaseLease()
        end

        def send_releaseLease(reqInfo, accountInfo)
          send_message("releaseLease", ReleaseLease_args, reqInfo: reqInfo, accountInfo: accountInfo)
        end

        def recv_releaseLease()
          result = receive_message(ReleaseLease_result)
          return result.success unless result.success.nil?
          raise result.storageException unless result.storageException.nil?
          raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, "releaseLease failed: unknown result")
        end

        def setPermissions(reqInfo, accountInfo, permissions)
          send_setPermissions(reqInfo, accountInfo, permissions)
          return recv_setPermissions()
        end

        def send_setPermissions(reqInfo, accountInfo, permissions)
          send_message("setPermissions", SetPermissions_args, reqInfo: reqInfo, accountInfo: accountInfo, permissions: permissions)
        end

        def recv_setPermissions()
          result = receive_message(SetPermissions_result)
          return result.success unless result.success.nil?
          raise result.storageException unless result.storageException.nil?
          raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, "setPermissions failed: unknown result")
        end

        def getPermissions(reqInfo, accountInfo)
          send_getPermissions(reqInfo, accountInfo)
          return recv_getPermissions()
        end

        def send_getPermissions(reqInfo, accountInfo)
          send_message("getPermissions", GetPermissions_args, reqInfo: reqInfo, accountInfo: accountInfo)
        end

        def recv_getPermissions()
          result = receive_message(GetPermissions_result)
          return result.success unless result.success.nil?
          raise result.storageException unless result.storageException.nil?
          raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, "getPermissions failed: unknown result")
        end
      end

      class Processor
        include ::Thrift::Processor

        def process_exists(seqid, iprot, oprot)
          args = read_args(iprot, Exists_args)
          result = Exists_result.new()
          begin
            result.success = @handler.exists(args.reqInfo, args.accountInfo)
          rescue ::XSS::AutoGenerated::WrappedStorageException => storageException
            result.storageException = storageException
          end
          write_result(result, oprot, "exists", seqid)
        end

        def process_fetchAttributes(seqid, iprot, oprot)
          args = read_args(iprot, FetchAttributes_args)
          result = FetchAttributes_result.new()
          begin
            result.success = @handler.fetchAttributes(args.reqInfo, args.accountInfo)
          rescue ::XSS::AutoGenerated::WrappedStorageException => wse
            result.wse = wse
          end
          write_result(result, oprot, "fetchAttributes", seqid)
        end

        def process_setMetadata(seqid, iprot, oprot)
          args = read_args(iprot, SetMetadata_args)
          result = SetMetadata_result.new()
          begin
            result.success = @handler.setMetadata(args.reqInfo, args.accountInfo, args.metadata)
          rescue ::XSS::AutoGenerated::WrappedStorageException => wse
            result.wse = wse
          end
          write_result(result, oprot, "setMetadata", seqid)
        end

        def process_createContainer(seqid, iprot, oprot)
          args = read_args(iprot, CreateContainer_args)
          result = CreateContainer_result.new()
          begin
            result.success = @handler.createContainer(args.reqInfo, args.accountInfo, args.accessType, args.createIfNotExists, args.metadata)
          rescue ::XSS::AutoGenerated::WrappedStorageException => storageException
            result.storageException = storageException
          end
          write_result(result, oprot, "createContainer", seqid)
        end

        def process_deleteContainer(seqid, iprot, oprot)
          args = read_args(iprot, DeleteContainer_args)
          result = DeleteContainer_result.new()
          begin
            result.success = @handler.deleteContainer(args.reqInfo, args.accountInfo, args.deleteIfExists)
          rescue ::XSS::AutoGenerated::WrappedStorageException => storageException
            result.storageException = storageException
          end
          write_result(result, oprot, "deleteContainer", seqid)
        end

        def process_listBlobs(seqid, iprot, oprot)
          args = read_args(iprot, ListBlobs_args)
          result = ListBlobs_result.new()
          begin
            result.success = @handler.listBlobs(args.listBlobsPayload, args.accountInfo, args.containerName)
          rescue ::XSS::AutoGenerated::WrappedStorageException => storageException
            result.storageException = storageException
          end
          write_result(result, oprot, "listBlobs", seqid)
        end

        def process_listBlobsSegmented(seqid, iprot, oprot)
          args = read_args(iprot, ListBlobsSegmented_args)
          result = ListBlobsSegmented_result.new()
          begin
            result.success = @handler.listBlobsSegmented(args.listBlobsPayload, args.accountInfo, args.maxResults, args.continuationToken, args.containerName)
          rescue ::XSS::AutoGenerated::WrappedStorageException => storageException
            result.storageException = storageException
          end
          write_result(result, oprot, "listBlobsSegmented", seqid)
        end

        def process_acquireLease(seqid, iprot, oprot)
          args = read_args(iprot, AcquireLease_args)
          result = AcquireLease_result.new()
          begin
            result.success = @handler.acquireLease(args.reqInfo, args.accountInfo, args.leaseTime, args.proposedLeaseId)
          rescue ::XSS::AutoGenerated::WrappedStorageException => storageException
            result.storageException = storageException
          end
          write_result(result, oprot, "acquireLease", seqid)
        end

        def process_changeLease(seqid, iprot, oprot)
          args = read_args(iprot, ChangeLease_args)
          result = ChangeLease_result.new()
          begin
            result.success = @handler.changeLease(args.reqInfo, args.accountInfo, args.proposedLeaseId)
          rescue ::XSS::AutoGenerated::WrappedStorageException => storageException
            result.storageException = storageException
          end
          write_result(result, oprot, "changeLease", seqid)
        end

        def process_breakLease(seqid, iprot, oprot)
          args = read_args(iprot, BreakLease_args)
          result = BreakLease_result.new()
          begin
            result.success = @handler.breakLease(args.reqInfo, args.accountInfo, args.breakPeriod)
          rescue ::XSS::AutoGenerated::WrappedStorageException => storageException
            result.storageException = storageException
          end
          write_result(result, oprot, "breakLease", seqid)
        end

        def process_renewLease(seqid, iprot, oprot)
          args = read_args(iprot, RenewLease_args)
          result = RenewLease_result.new()
          begin
            result.success = @handler.renewLease(args.reqInfo, args.accountInfo)
          rescue ::XSS::AutoGenerated::WrappedStorageException => storageException
            result.storageException = storageException
          end
          write_result(result, oprot, "renewLease", seqid)
        end

        def process_releaseLease(seqid, iprot, oprot)
          args = read_args(iprot, ReleaseLease_args)
          result = ReleaseLease_result.new()
          begin
            result.success = @handler.releaseLease(args.reqInfo, args.accountInfo)
          rescue ::XSS::AutoGenerated::WrappedStorageException => storageException
            result.storageException = storageException
          end
          write_result(result, oprot, "releaseLease", seqid)
        end

        def process_setPermissions(seqid, iprot, oprot)
          args = read_args(iprot, SetPermissions_args)
          result = SetPermissions_result.new()
          begin
            result.success = @handler.setPermissions(args.reqInfo, args.accountInfo, args.permissions)
          rescue ::XSS::AutoGenerated::WrappedStorageException => storageException
            result.storageException = storageException
          end
          write_result(result, oprot, "setPermissions", seqid)
        end

        def process_getPermissions(seqid, iprot, oprot)
          args = read_args(iprot, GetPermissions_args)
          result = GetPermissions_result.new()
          begin
            result.success = @handler.getPermissions(args.reqInfo, args.accountInfo)
          rescue ::XSS::AutoGenerated::WrappedStorageException => storageException
            result.storageException = storageException
          end
          write_result(result, oprot, "getPermissions", seqid)
        end
      end

      # HELPER FUNCTIONS AND STRUCTURES

      class Exists_args
        include ::Thrift::Struct, ::Thrift::Struct_Union
        REQINFO = 1
        ACCOUNTINFO = 2

        FIELDS = {
          REQINFO => { type: ::Thrift::Types::STRUCT, name: "reqInfo", class: ::XSS::AutoGenerated::ContainerRequestInfo },
          ACCOUNTINFO => { type: ::Thrift::Types::STRUCT, name: "accountInfo", class: ::XSS::AutoGenerated::StorageAccountInfo }
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class Exists_result
        include ::Thrift::Struct, ::Thrift::Struct_Union
        SUCCESS = 0
        STORAGEEXCEPTION = 1

        FIELDS = {
          SUCCESS => { type: ::Thrift::Types::STRUCT, name: "success", class: ::XSS::AutoGenerated::BlobContainerExistsResponse },
          STORAGEEXCEPTION => { type: ::Thrift::Types::STRUCT, name: "storageException", class: ::XSS::AutoGenerated::WrappedStorageException }
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class FetchAttributes_args
        include ::Thrift::Struct, ::Thrift::Struct_Union
        REQINFO = 1
        ACCOUNTINFO = 2

        FIELDS = {
          REQINFO => { type: ::Thrift::Types::STRUCT, name: "reqInfo", class: ::XSS::AutoGenerated::ContainerRequestInfo },
          ACCOUNTINFO => { type: ::Thrift::Types::STRUCT, name: "accountInfo", class: ::XSS::AutoGenerated::StorageAccountInfo }
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class FetchAttributes_result
        include ::Thrift::Struct, ::Thrift::Struct_Union
        SUCCESS = 0
        WSE = 1

        FIELDS = {
          SUCCESS => { type: ::Thrift::Types::STRUCT, name: "success", class: ::XSS::AutoGenerated::BlobContainerResponse },
          WSE => { type: ::Thrift::Types::STRUCT, name: "wse", class: ::XSS::AutoGenerated::WrappedStorageException }
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class SetMetadata_args
        include ::Thrift::Struct, ::Thrift::Struct_Union
        REQINFO = 1
        ACCOUNTINFO = 2
        METADATA = 3

        FIELDS = {
          REQINFO => { type: ::Thrift::Types::STRUCT, name: "reqInfo", class: ::XSS::AutoGenerated::ContainerRequestInfo },
          ACCOUNTINFO => { type: ::Thrift::Types::STRUCT, name: "accountInfo", class: ::XSS::AutoGenerated::StorageAccountInfo },
          METADATA => { type: ::Thrift::Types::MAP, name: "metadata", key: { type: ::Thrift::Types::STRING }, value: { type: ::Thrift::Types::STRING } }
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class SetMetadata_result
        include ::Thrift::Struct, ::Thrift::Struct_Union
        SUCCESS = 0
        WSE = 1

        FIELDS = {
          SUCCESS => { type: ::Thrift::Types::STRUCT, name: "success", class: ::XSS::AutoGenerated::BlobContainerResponse },
          WSE => { type: ::Thrift::Types::STRUCT, name: "wse", class: ::XSS::AutoGenerated::WrappedStorageException }
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class CreateContainer_args
        include ::Thrift::Struct, ::Thrift::Struct_Union
        REQINFO = 1
        ACCOUNTINFO = 2
        ACCESSTYPE = 3
        CREATEIFNOTEXISTS = 4
        METADATA = 5

        FIELDS = {
          REQINFO => { type: ::Thrift::Types::STRUCT, name: "reqInfo", class: ::XSS::AutoGenerated::ContainerRequestInfo },
          ACCOUNTINFO => { type: ::Thrift::Types::STRUCT, name: "accountInfo", class: ::XSS::AutoGenerated::StorageAccountInfo },
          ACCESSTYPE => { type: ::Thrift::Types::I32, name: "accessType", enum_class: ::XSS::AutoGenerated::BlobContainerPublicAccessType },
          CREATEIFNOTEXISTS => { type: ::Thrift::Types::BOOL, name: "createIfNotExists" },
          METADATA => { type: ::Thrift::Types::MAP, name: "metadata", key: { type: ::Thrift::Types::STRING }, value: { type: ::Thrift::Types::STRING } }
        }

        def struct_fields; FIELDS; end

        def validate
          unless @accessType.nil? || ::XSS::AutoGenerated::BlobContainerPublicAccessType::VALID_VALUES.include?(@accessType)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, "Invalid value of field accessType!")
          end
        end

        ::Thrift::Struct.generate_accessors self
      end

      class CreateContainer_result
        include ::Thrift::Struct, ::Thrift::Struct_Union
        SUCCESS = 0
        STORAGEEXCEPTION = 1

        FIELDS = {
          SUCCESS => { type: ::Thrift::Types::STRUCT, name: "success", class: ::XSS::AutoGenerated::CreateContainerResponse },
          STORAGEEXCEPTION => { type: ::Thrift::Types::STRUCT, name: "storageException", class: ::XSS::AutoGenerated::WrappedStorageException }
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class DeleteContainer_args
        include ::Thrift::Struct, ::Thrift::Struct_Union
        REQINFO = 1
        ACCOUNTINFO = 2
        DELETEIFEXISTS = 3

        FIELDS = {
          REQINFO => { type: ::Thrift::Types::STRUCT, name: "reqInfo", class: ::XSS::AutoGenerated::ContainerRequestInfo },
          ACCOUNTINFO => { type: ::Thrift::Types::STRUCT, name: "accountInfo", class: ::XSS::AutoGenerated::StorageAccountInfo },
          DELETEIFEXISTS => { type: ::Thrift::Types::BOOL, name: "deleteIfExists" }
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class DeleteContainer_result
        include ::Thrift::Struct, ::Thrift::Struct_Union
        SUCCESS = 0
        STORAGEEXCEPTION = 1

        FIELDS = {
          SUCCESS => { type: ::Thrift::Types::BOOL, name: "success" },
          STORAGEEXCEPTION => { type: ::Thrift::Types::STRUCT, name: "storageException", class: ::XSS::AutoGenerated::WrappedStorageException }
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class ListBlobs_args
        include ::Thrift::Struct, ::Thrift::Struct_Union
        LISTBLOBSPAYLOAD = 1
        ACCOUNTINFO = 2
        CONTAINERNAME = 3

        FIELDS = {
          LISTBLOBSPAYLOAD => { type: ::Thrift::Types::STRUCT, name: "listBlobsPayload", class: ::XSS::AutoGenerated::ListBlobsPayload },
          ACCOUNTINFO => { type: ::Thrift::Types::STRUCT, name: "accountInfo", class: ::XSS::AutoGenerated::StorageAccountInfo },
          CONTAINERNAME => { type: ::Thrift::Types::STRING, name: "containerName" }
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class ListBlobs_result
        include ::Thrift::Struct, ::Thrift::Struct_Union
        SUCCESS = 0
        STORAGEEXCEPTION = 1

        FIELDS = {
          SUCCESS => { type: ::Thrift::Types::STRUCT, name: "success", class: ::XSS::AutoGenerated::ListBlobsResponse },
          STORAGEEXCEPTION => { type: ::Thrift::Types::STRUCT, name: "storageException", class: ::XSS::AutoGenerated::WrappedStorageException }
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class ListBlobsSegmented_args
        include ::Thrift::Struct, ::Thrift::Struct_Union
        LISTBLOBSPAYLOAD = 1
        ACCOUNTINFO = 2
        MAXRESULTS = 3
        CONTINUATIONTOKEN = 4
        CONTAINERNAME = 5

        FIELDS = {
          LISTBLOBSPAYLOAD => { type: ::Thrift::Types::STRUCT, name: "listBlobsPayload", class: ::XSS::AutoGenerated::ListBlobsPayload },
          ACCOUNTINFO => { type: ::Thrift::Types::STRUCT, name: "accountInfo", class: ::XSS::AutoGenerated::StorageAccountInfo },
          MAXRESULTS => { type: ::Thrift::Types::I32, name: "maxResults" },
          CONTINUATIONTOKEN => { type: ::Thrift::Types::STRUCT, name: "continuationToken", class: ::XSS::AutoGenerated::ThriftBlobContinuationToken },
          CONTAINERNAME => { type: ::Thrift::Types::STRING, name: "containerName" }
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class ListBlobsSegmented_result
        include ::Thrift::Struct, ::Thrift::Struct_Union
        SUCCESS = 0
        STORAGEEXCEPTION = 1

        FIELDS = {
          SUCCESS => { type: ::Thrift::Types::STRUCT, name: "success", class: ::XSS::AutoGenerated::ListBlobsResponse },
          STORAGEEXCEPTION => { type: ::Thrift::Types::STRUCT, name: "storageException", class: ::XSS::AutoGenerated::WrappedStorageException }
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class AcquireLease_args
        include ::Thrift::Struct, ::Thrift::Struct_Union
        REQINFO = 1
        ACCOUNTINFO = 2
        LEASETIME = 3
        PROPOSEDLEASEID = 4

        FIELDS = {
          REQINFO => { type: ::Thrift::Types::STRUCT, name: "reqInfo", class: ::XSS::AutoGenerated::ContainerRequestInfo },
          ACCOUNTINFO => { type: ::Thrift::Types::STRUCT, name: "accountInfo", class: ::XSS::AutoGenerated::StorageAccountInfo },
          LEASETIME => { type: ::Thrift::Types::I32, name: "leaseTime" },
          PROPOSEDLEASEID => { type: ::Thrift::Types::STRING, name: "proposedLeaseId" }
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class AcquireLease_result
        include ::Thrift::Struct, ::Thrift::Struct_Union
        SUCCESS = 0
        STORAGEEXCEPTION = 1

        FIELDS = {
          SUCCESS => { type: ::Thrift::Types::STRUCT, name: "success", class: ::XSS::AutoGenerated::ContainerChangeAcquireLeaseResponse },
          STORAGEEXCEPTION => { type: ::Thrift::Types::STRUCT, name: "storageException", class: ::XSS::AutoGenerated::WrappedStorageException }
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class ChangeLease_args
        include ::Thrift::Struct, ::Thrift::Struct_Union
        REQINFO = 1
        ACCOUNTINFO = 2
        PROPOSEDLEASEID = 3

        FIELDS = {
          REQINFO => { type: ::Thrift::Types::STRUCT, name: "reqInfo", class: ::XSS::AutoGenerated::ContainerRequestInfo },
          ACCOUNTINFO => { type: ::Thrift::Types::STRUCT, name: "accountInfo", class: ::XSS::AutoGenerated::StorageAccountInfo },
          PROPOSEDLEASEID => { type: ::Thrift::Types::STRING, name: "proposedLeaseId" }
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class ChangeLease_result
        include ::Thrift::Struct, ::Thrift::Struct_Union
        SUCCESS = 0
        STORAGEEXCEPTION = 1

        FIELDS = {
          SUCCESS => { type: ::Thrift::Types::STRUCT, name: "success", class: ::XSS::AutoGenerated::ContainerChangeAcquireLeaseResponse },
          STORAGEEXCEPTION => { type: ::Thrift::Types::STRUCT, name: "storageException", class: ::XSS::AutoGenerated::WrappedStorageException }
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class BreakLease_args
        include ::Thrift::Struct, ::Thrift::Struct_Union
        REQINFO = 1
        ACCOUNTINFO = 2
        BREAKPERIOD = 3

        FIELDS = {
          REQINFO => { type: ::Thrift::Types::STRUCT, name: "reqInfo", class: ::XSS::AutoGenerated::ContainerRequestInfo },
          ACCOUNTINFO => { type: ::Thrift::Types::STRUCT, name: "accountInfo", class: ::XSS::AutoGenerated::StorageAccountInfo },
          BREAKPERIOD => { type: ::Thrift::Types::I32, name: "breakPeriod" }
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class BreakLease_result
        include ::Thrift::Struct, ::Thrift::Struct_Union
        SUCCESS = 0
        STORAGEEXCEPTION = 1

        FIELDS = {
          SUCCESS => { type: ::Thrift::Types::STRUCT, name: "success", class: ::XSS::AutoGenerated::ContainerBreakLeaseResponse },
          STORAGEEXCEPTION => { type: ::Thrift::Types::STRUCT, name: "storageException", class: ::XSS::AutoGenerated::WrappedStorageException }
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class RenewLease_args
        include ::Thrift::Struct, ::Thrift::Struct_Union
        REQINFO = 1
        ACCOUNTINFO = 2

        FIELDS = {
          REQINFO => { type: ::Thrift::Types::STRUCT, name: "reqInfo", class: ::XSS::AutoGenerated::ContainerRequestInfo },
          ACCOUNTINFO => { type: ::Thrift::Types::STRUCT, name: "accountInfo", class: ::XSS::AutoGenerated::StorageAccountInfo }
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class RenewLease_result
        include ::Thrift::Struct, ::Thrift::Struct_Union
        SUCCESS = 0
        STORAGEEXCEPTION = 1

        FIELDS = {
          SUCCESS => { type: ::Thrift::Types::STRUCT, name: "success", class: ::XSS::AutoGenerated::BlobContainerResponse },
          STORAGEEXCEPTION => { type: ::Thrift::Types::STRUCT, name: "storageException", class: ::XSS::AutoGenerated::WrappedStorageException }
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class ReleaseLease_args
        include ::Thrift::Struct, ::Thrift::Struct_Union
        REQINFO = 1
        ACCOUNTINFO = 2

        FIELDS = {
          REQINFO => { type: ::Thrift::Types::STRUCT, name: "reqInfo", class: ::XSS::AutoGenerated::ContainerRequestInfo },
          ACCOUNTINFO => { type: ::Thrift::Types::STRUCT, name: "accountInfo", class: ::XSS::AutoGenerated::StorageAccountInfo }
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class ReleaseLease_result
        include ::Thrift::Struct, ::Thrift::Struct_Union
        SUCCESS = 0
        STORAGEEXCEPTION = 1

        FIELDS = {
          SUCCESS => { type: ::Thrift::Types::STRUCT, name: "success", class: ::XSS::AutoGenerated::BlobContainerResponse },
          STORAGEEXCEPTION => { type: ::Thrift::Types::STRUCT, name: "storageException", class: ::XSS::AutoGenerated::WrappedStorageException }
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class SetPermissions_args
        include ::Thrift::Struct, ::Thrift::Struct_Union
        REQINFO = 1
        ACCOUNTINFO = 2
        PERMISSIONS = 3

        FIELDS = {
          REQINFO => { type: ::Thrift::Types::STRUCT, name: "reqInfo", class: ::XSS::AutoGenerated::ContainerRequestInfo },
          ACCOUNTINFO => { type: ::Thrift::Types::STRUCT, name: "accountInfo", class: ::XSS::AutoGenerated::StorageAccountInfo },
          PERMISSIONS => { type: ::Thrift::Types::STRUCT, name: "permissions", class: ::XSS::AutoGenerated::ThriftBlobContainerPermissions }
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class SetPermissions_result
        include ::Thrift::Struct, ::Thrift::Struct_Union
        SUCCESS = 0
        STORAGEEXCEPTION = 1

        FIELDS = {
          SUCCESS => { type: ::Thrift::Types::STRUCT, name: "success", class: ::XSS::AutoGenerated::BlobContainerResponse },
          STORAGEEXCEPTION => { type: ::Thrift::Types::STRUCT, name: "storageException", class: ::XSS::AutoGenerated::WrappedStorageException }
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class GetPermissions_args
        include ::Thrift::Struct, ::Thrift::Struct_Union
        REQINFO = 1
        ACCOUNTINFO = 2

        FIELDS = {
          REQINFO => { type: ::Thrift::Types::STRUCT, name: "reqInfo", class: ::XSS::AutoGenerated::ContainerRequestInfo },
          ACCOUNTINFO => { type: ::Thrift::Types::STRUCT, name: "accountInfo", class: ::XSS::AutoGenerated::StorageAccountInfo }
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class GetPermissions_result
        include ::Thrift::Struct, ::Thrift::Struct_Union
        SUCCESS = 0
        STORAGEEXCEPTION = 1

        FIELDS = {
          SUCCESS => { type: ::Thrift::Types::STRUCT, name: "success", class: ::XSS::AutoGenerated::ContainerGetPermissionsResponse },
          STORAGEEXCEPTION => { type: ::Thrift::Types::STRUCT, name: "storageException", class: ::XSS::AutoGenerated::WrappedStorageException }
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end
    end
  end
end
