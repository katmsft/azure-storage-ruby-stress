#
# Auto-generated by Thrift Compiler (0.9.2)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#

require "thrift"
require_relative "cloud_table_types"

module Azure::Storage::Stress
  module AutoGenerated
    module CloudTableService
      class Client
        include ::Thrift::Client

        def create(createIfNotExists, requestInfo, accountInfo)
          send_create(createIfNotExists, requestInfo, accountInfo)
          return recv_create()
        end

        def send_create(createIfNotExists, requestInfo, accountInfo)
          send_message("create", Create_args, createIfNotExists: createIfNotExists, requestInfo: requestInfo, accountInfo: accountInfo)
        end

        def recv_create()
          result = receive_message(Create_result)
          return result.success unless result.success.nil?
          raise result.storageException unless result.storageException.nil?
          raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, "create failed: unknown result")
        end

        def exists(requestInfo, accountInfo)
          send_exists(requestInfo, accountInfo)
          return recv_exists()
        end

        def send_exists(requestInfo, accountInfo)
          send_message("exists", Exists_args, requestInfo: requestInfo, accountInfo: accountInfo)
        end

        def recv_exists()
          result = receive_message(Exists_result)
          return result.success unless result.success.nil?
          raise result.storageException unless result.storageException.nil?
          raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, "exists failed: unknown result")
        end

        def deleteTable(deleteIfExists, requestInfo, accountInfo)
          send_deleteTable(deleteIfExists, requestInfo, accountInfo)
          return recv_deleteTable()
        end

        def send_deleteTable(deleteIfExists, requestInfo, accountInfo)
          send_message("deleteTable", DeleteTable_args, deleteIfExists: deleteIfExists, requestInfo: requestInfo, accountInfo: accountInfo)
        end

        def recv_deleteTable()
          result = receive_message(DeleteTable_result)
          return result.success unless result.success.nil?
          raise result.storageException unless result.storageException.nil?
          raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, "deleteTable failed: unknown result")
        end

        def setPermissions(reqInfo, accountInfo, permissions)
          send_setPermissions(reqInfo, accountInfo, permissions)
          recv_setPermissions()
        end

        def send_setPermissions(reqInfo, accountInfo, permissions)
          send_message("setPermissions", SetPermissions_args, reqInfo: reqInfo, accountInfo: accountInfo, permissions: permissions)
        end

        def recv_setPermissions()
          result = receive_message(SetPermissions_result)
          raise result.storageException unless result.storageException.nil?
          return
        end

        def getPermissions(reqInfo, accountInfo)
          send_getPermissions(reqInfo, accountInfo)
          return recv_getPermissions()
        end

        def send_getPermissions(reqInfo, accountInfo)
          send_message("getPermissions", GetPermissions_args, reqInfo: reqInfo, accountInfo: accountInfo)
        end

        def recv_getPermissions()
          result = receive_message(GetPermissions_result)
          return result.success unless result.success.nil?
          raise result.storageException unless result.storageException.nil?
          raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, "getPermissions failed: unknown result")
        end

        def Execute(operation, requestInfo, accountInfo)
          send_Execute(operation, requestInfo, accountInfo)
          return recv_Execute()
        end

        def send_Execute(operation, requestInfo, accountInfo)
          send_message("Execute", Execute_args, operation: operation, requestInfo: requestInfo, accountInfo: accountInfo)
        end

        def recv_Execute()
          result = receive_message(Execute_result)
          return result.success unless result.success.nil?
          raise result.wse unless result.wse.nil?
          raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, "Execute failed: unknown result")
        end

        def ExecuteBatch(operations, requestInfo, accountInfo)
          send_ExecuteBatch(operations, requestInfo, accountInfo)
          return recv_ExecuteBatch()
        end

        def send_ExecuteBatch(operations, requestInfo, accountInfo)
          send_message("ExecuteBatch", ExecuteBatch_args, operations: operations, requestInfo: requestInfo, accountInfo: accountInfo)
        end

        def recv_ExecuteBatch()
          result = receive_message(ExecuteBatch_result)
          return result.success unless result.success.nil?
          raise result.wse unless result.wse.nil?
          raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, "ExecuteBatch failed: unknown result")
        end

        def ExecuteQuery(tableQuery, requestInfo, accountInfo)
          send_ExecuteQuery(tableQuery, requestInfo, accountInfo)
          return recv_ExecuteQuery()
        end

        def send_ExecuteQuery(tableQuery, requestInfo, accountInfo)
          send_message("ExecuteQuery", ExecuteQuery_args, tableQuery: tableQuery, requestInfo: requestInfo, accountInfo: accountInfo)
        end

        def recv_ExecuteQuery()
          result = receive_message(ExecuteQuery_result)
          return result.success unless result.success.nil?
          raise result.wse unless result.wse.nil?
          raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, "ExecuteQuery failed: unknown result")
        end

        def ExecuteQuerySegment(tableQuery, continuationToken, requestInfo, accountInfo)
          send_ExecuteQuerySegment(tableQuery, continuationToken, requestInfo, accountInfo)
          return recv_ExecuteQuerySegment()
        end

        def send_ExecuteQuerySegment(tableQuery, continuationToken, requestInfo, accountInfo)
          send_message("ExecuteQuerySegment", ExecuteQuerySegment_args, tableQuery: tableQuery, continuationToken: continuationToken, requestInfo: requestInfo, accountInfo: accountInfo)
        end

        def recv_ExecuteQuerySegment()
          result = receive_message(ExecuteQuerySegment_result)
          return result.success unless result.success.nil?
          raise result.wse unless result.wse.nil?
          raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, "ExecuteQuerySegment failed: unknown result")
        end
      end

      class Processor
        include ::Thrift::Processor

        def process_create(seqid, iprot, oprot)
          args = read_args(iprot, Create_args)
          result = Create_result.new()
          begin
            result.success = @handler.create(args.createIfNotExists, args.requestInfo, args.accountInfo)
          rescue ::XSS::AutoGenerated::WrappedStorageException => storageException
            result.storageException = storageException
          end
          write_result(result, oprot, "create", seqid)
        end

        def process_exists(seqid, iprot, oprot)
          args = read_args(iprot, Exists_args)
          result = Exists_result.new()
          begin
            result.success = @handler.exists(args.requestInfo, args.accountInfo)
          rescue ::XSS::AutoGenerated::WrappedStorageException => storageException
            result.storageException = storageException
          end
          write_result(result, oprot, "exists", seqid)
        end

        def process_deleteTable(seqid, iprot, oprot)
          args = read_args(iprot, DeleteTable_args)
          result = DeleteTable_result.new()
          begin
            result.success = @handler.deleteTable(args.deleteIfExists, args.requestInfo, args.accountInfo)
          rescue ::XSS::AutoGenerated::WrappedStorageException => storageException
            result.storageException = storageException
          end
          write_result(result, oprot, "deleteTable", seqid)
        end

        def process_setPermissions(seqid, iprot, oprot)
          args = read_args(iprot, SetPermissions_args)
          result = SetPermissions_result.new()
          begin
            @handler.setPermissions(args.reqInfo, args.accountInfo, args.permissions)
          rescue ::XSS::AutoGenerated::WrappedStorageException => storageException
            result.storageException = storageException
          end
          write_result(result, oprot, "setPermissions", seqid)
        end

        def process_getPermissions(seqid, iprot, oprot)
          args = read_args(iprot, GetPermissions_args)
          result = GetPermissions_result.new()
          begin
            result.success = @handler.getPermissions(args.reqInfo, args.accountInfo)
          rescue ::XSS::AutoGenerated::WrappedStorageException => storageException
            result.storageException = storageException
          end
          write_result(result, oprot, "getPermissions", seqid)
        end

        def process_Execute(seqid, iprot, oprot)
          args = read_args(iprot, Execute_args)
          result = Execute_result.new()
          begin
            result.success = @handler.Execute(args.operation, args.requestInfo, args.accountInfo)
          rescue ::XSS::AutoGenerated::WrappedStorageException => wse
            result.wse = wse
          end
          write_result(result, oprot, "Execute", seqid)
        end

        def process_ExecuteBatch(seqid, iprot, oprot)
          args = read_args(iprot, ExecuteBatch_args)
          result = ExecuteBatch_result.new()
          begin
            result.success = @handler.ExecuteBatch(args.operations, args.requestInfo, args.accountInfo)
          rescue ::XSS::AutoGenerated::WrappedStorageException => wse
            result.wse = wse
          end
          write_result(result, oprot, "ExecuteBatch", seqid)
        end

        def process_ExecuteQuery(seqid, iprot, oprot)
          args = read_args(iprot, ExecuteQuery_args)
          result = ExecuteQuery_result.new()
          begin
            result.success = @handler.ExecuteQuery(args.tableQuery, args.requestInfo, args.accountInfo)
          rescue ::XSS::AutoGenerated::WrappedStorageException => wse
            result.wse = wse
          end
          write_result(result, oprot, "ExecuteQuery", seqid)
        end

        def process_ExecuteQuerySegment(seqid, iprot, oprot)
          args = read_args(iprot, ExecuteQuerySegment_args)
          result = ExecuteQuerySegment_result.new()
          begin
            result.success = @handler.ExecuteQuerySegment(args.tableQuery, args.continuationToken, args.requestInfo, args.accountInfo)
          rescue ::XSS::AutoGenerated::WrappedStorageException => wse
            result.wse = wse
          end
          write_result(result, oprot, "ExecuteQuerySegment", seqid)
        end
      end

      # HELPER FUNCTIONS AND STRUCTURES

      class Create_args
        include ::Thrift::Struct, ::Thrift::Struct_Union
        CREATEIFNOTEXISTS = 1
        REQUESTINFO = 2
        ACCOUNTINFO = 3

        FIELDS = {
          CREATEIFNOTEXISTS => { type: ::Thrift::Types::BOOL, name: "createIfNotExists" },
          REQUESTINFO => { type: ::Thrift::Types::STRUCT, name: "requestInfo", class: ::XSS::AutoGenerated::TableRequestInfo },
          ACCOUNTINFO => { type: ::Thrift::Types::STRUCT, name: "accountInfo", class: ::XSS::AutoGenerated::StorageAccountInfo }
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class Create_result
        include ::Thrift::Struct, ::Thrift::Struct_Union
        SUCCESS = 0
        STORAGEEXCEPTION = 1

        FIELDS = {
          SUCCESS => { type: ::Thrift::Types::BOOL, name: "success" },
          STORAGEEXCEPTION => { type: ::Thrift::Types::STRUCT, name: "storageException", class: ::XSS::AutoGenerated::WrappedStorageException }
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class Exists_args
        include ::Thrift::Struct, ::Thrift::Struct_Union
        REQUESTINFO = 1
        ACCOUNTINFO = 2

        FIELDS = {
          REQUESTINFO => { type: ::Thrift::Types::STRUCT, name: "requestInfo", class: ::XSS::AutoGenerated::TableRequestInfo },
          ACCOUNTINFO => { type: ::Thrift::Types::STRUCT, name: "accountInfo", class: ::XSS::AutoGenerated::StorageAccountInfo }
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class Exists_result
        include ::Thrift::Struct, ::Thrift::Struct_Union
        SUCCESS = 0
        STORAGEEXCEPTION = 1

        FIELDS = {
          SUCCESS => { type: ::Thrift::Types::BOOL, name: "success" },
          STORAGEEXCEPTION => { type: ::Thrift::Types::STRUCT, name: "storageException", class: ::XSS::AutoGenerated::WrappedStorageException }
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class DeleteTable_args
        include ::Thrift::Struct, ::Thrift::Struct_Union
        DELETEIFEXISTS = 1
        REQUESTINFO = 2
        ACCOUNTINFO = 3

        FIELDS = {
          DELETEIFEXISTS => { type: ::Thrift::Types::BOOL, name: "deleteIfExists" },
          REQUESTINFO => { type: ::Thrift::Types::STRUCT, name: "requestInfo", class: ::XSS::AutoGenerated::TableRequestInfo },
          ACCOUNTINFO => { type: ::Thrift::Types::STRUCT, name: "accountInfo", class: ::XSS::AutoGenerated::StorageAccountInfo }
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class DeleteTable_result
        include ::Thrift::Struct, ::Thrift::Struct_Union
        SUCCESS = 0
        STORAGEEXCEPTION = 1

        FIELDS = {
          SUCCESS => { type: ::Thrift::Types::BOOL, name: "success" },
          STORAGEEXCEPTION => { type: ::Thrift::Types::STRUCT, name: "storageException", class: ::XSS::AutoGenerated::WrappedStorageException }
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class SetPermissions_args
        include ::Thrift::Struct, ::Thrift::Struct_Union
        REQINFO = 1
        ACCOUNTINFO = 2
        PERMISSIONS = 3

        FIELDS = {
          REQINFO => { type: ::Thrift::Types::STRUCT, name: "reqInfo", class: ::XSS::AutoGenerated::TableRequestInfo },
          ACCOUNTINFO => { type: ::Thrift::Types::STRUCT, name: "accountInfo", class: ::XSS::AutoGenerated::StorageAccountInfo },
          PERMISSIONS => { type: ::Thrift::Types::STRUCT, name: "permissions", class: ::XSS::AutoGenerated::ThriftTablePermissions }
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class SetPermissions_result
        include ::Thrift::Struct, ::Thrift::Struct_Union
        STORAGEEXCEPTION = 1

        FIELDS = {
          STORAGEEXCEPTION => { type: ::Thrift::Types::STRUCT, name: "storageException", class: ::XSS::AutoGenerated::WrappedStorageException }
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class GetPermissions_args
        include ::Thrift::Struct, ::Thrift::Struct_Union
        REQINFO = 1
        ACCOUNTINFO = 2

        FIELDS = {
          REQINFO => { type: ::Thrift::Types::STRUCT, name: "reqInfo", class: ::XSS::AutoGenerated::TableRequestInfo },
          ACCOUNTINFO => { type: ::Thrift::Types::STRUCT, name: "accountInfo", class: ::XSS::AutoGenerated::StorageAccountInfo }
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class GetPermissions_result
        include ::Thrift::Struct, ::Thrift::Struct_Union
        SUCCESS = 0
        STORAGEEXCEPTION = 1

        FIELDS = {
          SUCCESS => { type: ::Thrift::Types::STRUCT, name: "success", class: ::XSS::AutoGenerated::ThriftTablePermissions },
          STORAGEEXCEPTION => { type: ::Thrift::Types::STRUCT, name: "storageException", class: ::XSS::AutoGenerated::WrappedStorageException }
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class Execute_args
        include ::Thrift::Struct, ::Thrift::Struct_Union
        OPERATION = 1
        REQUESTINFO = 2
        ACCOUNTINFO = 3

        FIELDS = {
          OPERATION => { type: ::Thrift::Types::STRUCT, name: "operation", class: ::XSS::AutoGenerated::ThriftTableOperation },
          REQUESTINFO => { type: ::Thrift::Types::STRUCT, name: "requestInfo", class: ::XSS::AutoGenerated::TableRequestInfo },
          ACCOUNTINFO => { type: ::Thrift::Types::STRUCT, name: "accountInfo", class: ::XSS::AutoGenerated::StorageAccountInfo }
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class Execute_result
        include ::Thrift::Struct, ::Thrift::Struct_Union
        SUCCESS = 0
        WSE = 1

        FIELDS = {
          SUCCESS => { type: ::Thrift::Types::STRUCT, name: "success", class: ::XSS::AutoGenerated::ThriftTableResult },
          WSE => { type: ::Thrift::Types::STRUCT, name: "wse", class: ::XSS::AutoGenerated::WrappedStorageException }
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class ExecuteBatch_args
        include ::Thrift::Struct, ::Thrift::Struct_Union
        OPERATIONS = 1
        REQUESTINFO = 2
        ACCOUNTINFO = 3

        FIELDS = {
          OPERATIONS => { type: ::Thrift::Types::LIST, name: "operations", element: { type: ::Thrift::Types::STRUCT, class: ::XSS::AutoGenerated::ThriftTableOperation } },
          REQUESTINFO => { type: ::Thrift::Types::STRUCT, name: "requestInfo", class: ::XSS::AutoGenerated::TableRequestInfo },
          ACCOUNTINFO => { type: ::Thrift::Types::STRUCT, name: "accountInfo", class: ::XSS::AutoGenerated::StorageAccountInfo }
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class ExecuteBatch_result
        include ::Thrift::Struct, ::Thrift::Struct_Union
        SUCCESS = 0
        WSE = 1

        FIELDS = {
          SUCCESS => { type: ::Thrift::Types::LIST, name: "success", element: { type: ::Thrift::Types::STRUCT, class: ::XSS::AutoGenerated::ThriftTableResult } },
          WSE => { type: ::Thrift::Types::STRUCT, name: "wse", class: ::XSS::AutoGenerated::WrappedStorageException }
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class ExecuteQuery_args
        include ::Thrift::Struct, ::Thrift::Struct_Union
        TABLEQUERY = 1
        REQUESTINFO = 2
        ACCOUNTINFO = 3

        FIELDS = {
          TABLEQUERY => { type: ::Thrift::Types::STRUCT, name: "tableQuery", class: ::XSS::AutoGenerated::ThriftTableQuery },
          REQUESTINFO => { type: ::Thrift::Types::STRUCT, name: "requestInfo", class: ::XSS::AutoGenerated::TableRequestInfo },
          ACCOUNTINFO => { type: ::Thrift::Types::STRUCT, name: "accountInfo", class: ::XSS::AutoGenerated::StorageAccountInfo }
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class ExecuteQuery_result
        include ::Thrift::Struct, ::Thrift::Struct_Union
        SUCCESS = 0
        WSE = 1

        FIELDS = {
          SUCCESS => { type: ::Thrift::Types::LIST, name: "success", element: { type: ::Thrift::Types::STRUCT, class: ::XSS::AutoGenerated::ThriftTableEntity } },
          WSE => { type: ::Thrift::Types::STRUCT, name: "wse", class: ::XSS::AutoGenerated::WrappedStorageException }
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class ExecuteQuerySegment_args
        include ::Thrift::Struct, ::Thrift::Struct_Union
        TABLEQUERY = 1
        CONTINUATIONTOKEN = 2
        REQUESTINFO = 3
        ACCOUNTINFO = 4

        FIELDS = {
          TABLEQUERY => { type: ::Thrift::Types::STRUCT, name: "tableQuery", class: ::XSS::AutoGenerated::ThriftTableQuery },
          CONTINUATIONTOKEN => { type: ::Thrift::Types::STRUCT, name: "continuationToken", class: ::XSS::AutoGenerated::ThriftTableContinuationToken },
          REQUESTINFO => { type: ::Thrift::Types::STRUCT, name: "requestInfo", class: ::XSS::AutoGenerated::TableRequestInfo },
          ACCOUNTINFO => { type: ::Thrift::Types::STRUCT, name: "accountInfo", class: ::XSS::AutoGenerated::StorageAccountInfo }
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class ExecuteQuerySegment_result
        include ::Thrift::Struct, ::Thrift::Struct_Union
        SUCCESS = 0
        WSE = 1

        FIELDS = {
          SUCCESS => { type: ::Thrift::Types::STRUCT, name: "success", class: ::XSS::AutoGenerated::TableQueryResultSegment },
          WSE => { type: ::Thrift::Types::STRUCT, name: "wse", class: ::XSS::AutoGenerated::WrappedStorageException }
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end
    end
  end
end
