#
# Auto-generated by Thrift Compiler (0.9.2)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#

require "thrift"

module Azure
  module Storage
    module Stress
    end
  end
end

XSS = Azure::Storage::Stress

module Azure::Storage::Stress
  module AutoGenerated
    module Features
      # This is for internal use by the ProxyAdapter infrastructure. Service implementations shouldn't
      # return this as a supported feature
      None = 0
      BlobClient_ListBlobs = 1
      BlobClient_ListBlobsSegmented = 2
      BlobClient_ListContainers = 3
      BlobClient_ListContainersSegmented = 4
      BlobClient_SetServiceProperties = 5
      BlobClient_GetServiceProperties = 6
      BlobClient_GetServiceStats = 7
      Container_Create = 8
      Container_Exists = 9
      Container_Delete = 10
      Container_FetchAttributes = 11
      Container_SetMetadata = 12
      Container_AcquireLease = 13
      Container_BreakLease = 14
      Container_ChangeLease = 15
      Container_RenewLease = 16
      Container_ReleaseLease = 17
      Container_SetPermissions = 18
      Container_GetPermissions = 19
      Container_ListBlobs = 20
      Container_ListBlobsSegmented = 21
      Blob_Exists = 22
      Blob_Delete = 23
      Blob_SetMetadata = 24
      Blob_SetProperties = 25
      Blob_FetchAttributes = 26
      Blob_UploadFromStream = 27
      Blob_DownloadToStream = 28
      Blob_DownloadRangeToStream = 29
      Blob_UploadFromByteArray = 30
      Blob_DownloadToByteArray = 31
      Blob_DownloadRangeToByteArray = 32
      Blob_UploadFromFile = 33
      Blob_DownloadToFile = 34
      Blob_AcquireLease = 35
      Blob_BreakLease = 36
      Blob_ChangeLease = 37
      Blob_ReleaseLease = 38
      Blob_RenewLease = 39
      Blob_StartCopyFromBlob = 40
      Blob_AbortCopy = 41
      Blob_CreateSnapShot = 42
      Blob_SoftDelete = 43
      BlockBlob_PutBlock = 44
      BlockBlob_PutBlockList = 45
      BlockBlob_DownloadBlockList = 46
      BlockBlob_DownloadText = 47
      BlockBlob_UploadText = 48
      BlockBlob_SetStandardBlobTier = 49
      PageBlob_Create = 50
      PageBlob_Resize = 51
      PageBlob_SetSequenceNumber = 52
      PageBlob_WritePages = 53
      PageBlob_GetPageRanges = 54
      PageBlob_GetPageRangesDiff = 55
      PageBlob_ClearPages = 56
      PageBlob_IncrementalCopy = 57
      PageBlob_SetPremiumPageBlobTier = 58
      AppendBlob_Create = 59
      AppendBlob_AppendFromByteArray = 60
      AppendBlob_AppendBlock = 61
      AppendBlob_DownloadText = 62
      File_Create = 63
      File_WriteRange = 64
      File_Delete = 65
      File_SetMetadata = 66
      File_SetProperties = 67
      File_FetchAttributes = 68
      File_Exists = 69
      File_Resize = 70
      File_ClearRange = 71
      File_ListRanges = 72
      File_UploadFromByteArray = 73
      File_DownloadToByteArray = 74
      File_DownloadRangeToByteArray = 75
      File_UploadFromStream = 76
      File_StartCopy = 77
      File_AbortCopy = 78
      FileDirectory_Create = 79
      FileDirectory_Delete = 80
      FileDirectory_Exists = 81
      FileDirectory_FetchAttributes = 82
      FileDirectory_List = 83
      FileDirectory_ListSegmented = 84
      FileDirectory_SetMetadata = 85
      FileShare_Create = 86
      FileShare_Delete = 87
      FileShare_Exists = 88
      FileShare_FetchAttributes = 89
      FileShare_SetMetadata = 90
      FileShare_SetProperties = 91
      FileShare_GetShareStats = 92
      FileShare_SetPermissions = 93
      FileShare_GetPermissions = 94
      FileShare_SnapshotShare = 95
      FileClient_ListShares = 96
      FileClient_ListSharesSegmented = 97
      FileClient_GetServiceProperties = 98
      FileClient_SetServiceProperties = 99
      Table_Create = 100
      Table_Delete = 101
      Table_Exists = 102
      Table_SetPermissions = 103
      Table_GetPermissions = 104
      Table_Execute = 105
      Table_ExecuteBatch = 106
      Table_ExecuteQuery = 107
      Table_ExecuteQuerySegment = 108
      TableClient_GetServiceStats = 109
      TableClient_GetServiceProperties = 110
      TableClient_SetServiceProperties = 111
      TableClient_ListTables = 112
      TableClient_ListTablesSegmented = 113
      Queue_Create = 114
      Queue_Delete = 115
      Queue_Exists = 116
      Queue_ClearMessages = 117
      Queue_FetchAttributes = 118
      Queue_SetMetadata = 119
      Queue_UpdateMessage = 120
      Queue_AddMessage = 121
      Queue_GetMessage = 122
      Queue_GetMessages = 123
      Queue_PeekMessage = 124
      Queue_PeekMessages = 125
      Queue_DeleteMessage = 126
      Queue_SetPermissions = 127
      Queue_GetPermissions = 128
      QueueClient_ListQueues = 129
      QueueClient_ListQueuesSegmented = 130
      QueueClient_SetProperties = 131
      QueueClient_GetProperties = 132
      QueueClient_GetServiceStats = 133
      VALUE_MAP = { 0 => "None", 1 => "BlobClient_ListBlobs", 2 => "BlobClient_ListBlobsSegmented", 3 => "BlobClient_ListContainers", 4 => "BlobClient_ListContainersSegmented", 5 => "BlobClient_SetServiceProperties", 6 => "BlobClient_GetServiceProperties", 7 => "BlobClient_GetServiceStats", 8 => "Container_Create", 9 => "Container_Exists", 10 => "Container_Delete", 11 => "Container_FetchAttributes", 12 => "Container_SetMetadata", 13 => "Container_AcquireLease", 14 => "Container_BreakLease", 15 => "Container_ChangeLease", 16 => "Container_RenewLease", 17 => "Container_ReleaseLease", 18 => "Container_SetPermissions", 19 => "Container_GetPermissions", 20 => "Container_ListBlobs", 21 => "Container_ListBlobsSegmented", 22 => "Blob_Exists", 23 => "Blob_Delete", 24 => "Blob_SetMetadata", 25 => "Blob_SetProperties", 26 => "Blob_FetchAttributes", 27 => "Blob_UploadFromStream", 28 => "Blob_DownloadToStream", 29 => "Blob_DownloadRangeToStream", 30 => "Blob_UploadFromByteArray", 31 => "Blob_DownloadToByteArray", 32 => "Blob_DownloadRangeToByteArray", 33 => "Blob_UploadFromFile", 34 => "Blob_DownloadToFile", 35 => "Blob_AcquireLease", 36 => "Blob_BreakLease", 37 => "Blob_ChangeLease", 38 => "Blob_ReleaseLease", 39 => "Blob_RenewLease", 40 => "Blob_StartCopyFromBlob", 41 => "Blob_AbortCopy", 42 => "Blob_CreateSnapShot", 43 => "Blob_SoftDelete", 44 => "BlockBlob_PutBlock", 45 => "BlockBlob_PutBlockList", 46 => "BlockBlob_DownloadBlockList", 47 => "BlockBlob_DownloadText", 48 => "BlockBlob_UploadText", 49 => "BlockBlob_SetStandardBlobTier", 50 => "PageBlob_Create", 51 => "PageBlob_Resize", 52 => "PageBlob_SetSequenceNumber", 53 => "PageBlob_WritePages", 54 => "PageBlob_GetPageRanges", 55 => "PageBlob_GetPageRangesDiff", 56 => "PageBlob_ClearPages", 57 => "PageBlob_IncrementalCopy", 58 => "PageBlob_SetPremiumPageBlobTier", 59 => "AppendBlob_Create", 60 => "AppendBlob_AppendFromByteArray", 61 => "AppendBlob_AppendBlock", 62 => "AppendBlob_DownloadText", 63 => "File_Create", 64 => "File_WriteRange", 65 => "File_Delete", 66 => "File_SetMetadata", 67 => "File_SetProperties", 68 => "File_FetchAttributes", 69 => "File_Exists", 70 => "File_Resize", 71 => "File_ClearRange", 72 => "File_ListRanges", 73 => "File_UploadFromByteArray", 74 => "File_DownloadToByteArray", 75 => "File_DownloadRangeToByteArray", 76 => "File_UploadFromStream", 77 => "File_StartCopy", 78 => "File_AbortCopy", 79 => "FileDirectory_Create", 80 => "FileDirectory_Delete", 81 => "FileDirectory_Exists", 82 => "FileDirectory_FetchAttributes", 83 => "FileDirectory_List", 84 => "FileDirectory_ListSegmented", 85 => "FileDirectory_SetMetadata", 86 => "FileShare_Create", 87 => "FileShare_Delete", 88 => "FileShare_Exists", 89 => "FileShare_FetchAttributes", 90 => "FileShare_SetMetadata", 91 => "FileShare_SetProperties", 92 => "FileShare_GetShareStats", 93 => "FileShare_SetPermissions", 94 => "FileShare_GetPermissions", 95 => "FileShare_SnapshotShare", 96 => "FileClient_ListShares", 97 => "FileClient_ListSharesSegmented", 98 => "FileClient_GetServiceProperties", 99 => "FileClient_SetServiceProperties", 100 => "Table_Create", 101 => "Table_Delete", 102 => "Table_Exists", 103 => "Table_SetPermissions", 104 => "Table_GetPermissions", 105 => "Table_Execute", 106 => "Table_ExecuteBatch", 107 => "Table_ExecuteQuery", 108 => "Table_ExecuteQuerySegment", 109 => "TableClient_GetServiceStats", 110 => "TableClient_GetServiceProperties", 111 => "TableClient_SetServiceProperties", 112 => "TableClient_ListTables", 113 => "TableClient_ListTablesSegmented", 114 => "Queue_Create", 115 => "Queue_Delete", 116 => "Queue_Exists", 117 => "Queue_ClearMessages", 118 => "Queue_FetchAttributes", 119 => "Queue_SetMetadata", 120 => "Queue_UpdateMessage", 121 => "Queue_AddMessage", 122 => "Queue_GetMessage", 123 => "Queue_GetMessages", 124 => "Queue_PeekMessage", 125 => "Queue_PeekMessages", 126 => "Queue_DeleteMessage", 127 => "Queue_SetPermissions", 128 => "Queue_GetPermissions", 129 => "QueueClient_ListQueues", 130 => "QueueClient_ListQueuesSegmented", 131 => "QueueClient_SetProperties", 132 => "QueueClient_GetProperties", 133 => "QueueClient_GetServiceStats" }
      VALID_VALUES = Set.new([None, BlobClient_ListBlobs, BlobClient_ListBlobsSegmented, BlobClient_ListContainers, BlobClient_ListContainersSegmented, BlobClient_SetServiceProperties, BlobClient_GetServiceProperties, BlobClient_GetServiceStats, Container_Create, Container_Exists, Container_Delete, Container_FetchAttributes, Container_SetMetadata, Container_AcquireLease, Container_BreakLease, Container_ChangeLease, Container_RenewLease, Container_ReleaseLease, Container_SetPermissions, Container_GetPermissions, Container_ListBlobs, Container_ListBlobsSegmented, Blob_Exists, Blob_Delete, Blob_SetMetadata, Blob_SetProperties, Blob_FetchAttributes, Blob_UploadFromStream, Blob_DownloadToStream, Blob_DownloadRangeToStream, Blob_UploadFromByteArray, Blob_DownloadToByteArray, Blob_DownloadRangeToByteArray, Blob_UploadFromFile, Blob_DownloadToFile, Blob_AcquireLease, Blob_BreakLease, Blob_ChangeLease, Blob_ReleaseLease, Blob_RenewLease, Blob_StartCopyFromBlob, Blob_AbortCopy, Blob_CreateSnapShot, Blob_SoftDelete, BlockBlob_PutBlock, BlockBlob_PutBlockList, BlockBlob_DownloadBlockList, BlockBlob_DownloadText, BlockBlob_UploadText, BlockBlob_SetStandardBlobTier, PageBlob_Create, PageBlob_Resize, PageBlob_SetSequenceNumber, PageBlob_WritePages, PageBlob_GetPageRanges, PageBlob_GetPageRangesDiff, PageBlob_ClearPages, PageBlob_IncrementalCopy, PageBlob_SetPremiumPageBlobTier, AppendBlob_Create, AppendBlob_AppendFromByteArray, AppendBlob_AppendBlock, AppendBlob_DownloadText, File_Create, File_WriteRange, File_Delete, File_SetMetadata, File_SetProperties, File_FetchAttributes, File_Exists, File_Resize, File_ClearRange, File_ListRanges, File_UploadFromByteArray, File_DownloadToByteArray, File_DownloadRangeToByteArray, File_UploadFromStream, File_StartCopy, File_AbortCopy, FileDirectory_Create, FileDirectory_Delete, FileDirectory_Exists, FileDirectory_FetchAttributes, FileDirectory_List, FileDirectory_ListSegmented, FileDirectory_SetMetadata, FileShare_Create, FileShare_Delete, FileShare_Exists, FileShare_FetchAttributes, FileShare_SetMetadata, FileShare_SetProperties, FileShare_GetShareStats, FileShare_SetPermissions, FileShare_GetPermissions, FileShare_SnapshotShare, FileClient_ListShares, FileClient_ListSharesSegmented, FileClient_GetServiceProperties, FileClient_SetServiceProperties, Table_Create, Table_Delete, Table_Exists, Table_SetPermissions, Table_GetPermissions, Table_Execute, Table_ExecuteBatch, Table_ExecuteQuery, Table_ExecuteQuerySegment, TableClient_GetServiceStats, TableClient_GetServiceProperties, TableClient_SetServiceProperties, TableClient_ListTables, TableClient_ListTablesSegmented, Queue_Create, Queue_Delete, Queue_Exists, Queue_ClearMessages, Queue_FetchAttributes, Queue_SetMetadata, Queue_UpdateMessage, Queue_AddMessage, Queue_GetMessage, Queue_GetMessages, Queue_PeekMessage, Queue_PeekMessages, Queue_DeleteMessage, Queue_SetPermissions, Queue_GetPermissions, QueueClient_ListQueues, QueueClient_ListQueuesSegmented, QueueClient_SetProperties, QueueClient_GetProperties, QueueClient_GetServiceStats]).freeze
    end

    module StorageLocation
      Primary = 0
      Secondary = 1
      VALUE_MAP = { 0 => "Primary", 1 => "Secondary" }
      VALID_VALUES = Set.new([Primary, Secondary]).freeze
    end

    module LocationMode
      PrimaryOnly = 0
      PrimaryThenSecondary = 1
      SecondaryOnly = 2
      SecondaryThenPrimary = 3
      VALUE_MAP = { 0 => "PrimaryOnly", 1 => "PrimaryThenSecondary", 2 => "SecondaryOnly", 3 => "SecondaryThenPrimary" }
      VALID_VALUES = Set.new([PrimaryOnly, PrimaryThenSecondary, SecondaryOnly, SecondaryThenPrimary]).freeze
    end

    module StorageCredentialsType
      Public = 0
      SharedKey = 1
      Sas = 2
      VALUE_MAP = { 0 => "Public", 1 => "SharedKey", 2 => "Sas" }
      VALID_VALUES = Set.new([Public, SharedKey, Sas]).freeze
    end

    module FileMode
      Append = 0
      Create = 1
      CreateNew = 2
      Open = 3
      OpenOrCreate = 4
      Truncate = 5
      VALUE_MAP = { 0 => "Append", 1 => "Create", 2 => "CreateNew", 3 => "Open", 4 => "OpenOrCreate", 5 => "Truncate" }
      VALID_VALUES = Set.new([Append, Create, CreateNew, Open, OpenOrCreate, Truncate]).freeze
    end

    module CorsHttpMethods
      None = 0
      Get = 1
      Head = 2
      Post = 4
      Put = 8
      Delete = 16
      Trace = 32
      Options = 64
      Connect = 128
      Merge = 256
      VALUE_MAP = { 0 => "None", 1 => "Get", 2 => "Head", 4 => "Post", 8 => "Put", 16 => "Delete", 32 => "Trace", 64 => "Options", 128 => "Connect", 256 => "Merge" }
      VALID_VALUES = Set.new([None, Get, Head, Post, Put, Delete, Trace, Options, Connect, Merge]).freeze
    end

    module MetricsLevel
      None = 0
      Service = 1
      ServiceAndApi = 2
      VALUE_MAP = { 0 => "None", 1 => "Service", 2 => "ServiceAndApi" }
      VALID_VALUES = Set.new([None, Service, ServiceAndApi]).freeze
    end

    module LoggingOperations
      None = 0
      Read = 1
      Write = 2
      Delete = 4
      All = 7
      VALUE_MAP = { 0 => "None", 1 => "Read", 2 => "Write", 4 => "Delete", 7 => "All" }
      VALID_VALUES = Set.new([None, Read, Write, Delete, All]).freeze
    end

    module GeoReplicationStatus
      Unavailable = 0
      Live = 1
      Bootstrap = 2
      VALUE_MAP = { 0 => "Unavailable", 1 => "Live", 2 => "Bootstrap" }
      VALID_VALUES = Set.new([Unavailable, Live, Bootstrap]).freeze
    end

    module ThriftCopyStatus
      Invalid = 0
      Pending = 1
      Success = 2
      Aborted = 3
      Failed = 4
      VALUE_MAP = { 0 => "Invalid", 1 => "Pending", 2 => "Success", 3 => "Aborted", 4 => "Failed" }
      VALID_VALUES = Set.new([Invalid, Pending, Success, Aborted, Failed]).freeze
    end

    class CloudStorageUri
      include ::Thrift::Struct, ::Thrift::Struct_Union
      PRIMARYURI = 1
      SECONDARYURI = 2

      FIELDS = {
        PRIMARYURI => { type: ::Thrift::Types::STRING, name: "primaryUri" },
        SECONDARYURI => { type: ::Thrift::Types::STRING, name: "secondaryUri", optional: true }
      }

      def struct_fields; FIELDS; end

      def validate
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, "Required field primaryUri is unset!") unless @primaryUri
      end

      ::Thrift::Struct.generate_accessors self
    end

    class RequestResult
      include ::Thrift::Struct, ::Thrift::Struct_Union
      ENDTIME = 1
      STARTTIME = 2
      ETAG = 3
      HTTPSTATUSCODE = 4
      SERVICEREQUESTID = 5
      CONTENTMD5 = 6
      REQUESTDATE = 7
      TARGETLOCATION = 8
      EGRESSBYTES = 9
      HTTPSTATUSMESSAGE = 10
      INGRESSBYTES = 11
      EXTENDEDERRORMESSAGE = 12
      EXTENDEDERRORCODE = 13
      EXTENDEDERRORDETAILS = 14

      FIELDS = {
        ENDTIME => { type: ::Thrift::Types::I64, name: "endTime" },
        STARTTIME => { type: ::Thrift::Types::I64, name: "startTime" },
        ETAG => { type: ::Thrift::Types::STRING, name: "etag" },
        HTTPSTATUSCODE => { type: ::Thrift::Types::I32, name: "httpStatusCode" },
        SERVICEREQUESTID => { type: ::Thrift::Types::STRING, name: "serviceRequestId" },
        CONTENTMD5 => { type: ::Thrift::Types::STRING, name: "contentMd5", optional: true },
        REQUESTDATE => { type: ::Thrift::Types::STRING, name: "requestDate", optional: true },
        TARGETLOCATION => { type: ::Thrift::Types::I32, name: "targetLocation", optional: true, enum_class: ::XSS::AutoGenerated::StorageLocation },
        EGRESSBYTES => { type: ::Thrift::Types::I64, name: "egressBytes", optional: true },
        HTTPSTATUSMESSAGE => { type: ::Thrift::Types::STRING, name: "httpStatusMessage", optional: true },
        INGRESSBYTES => { type: ::Thrift::Types::I64, name: "ingressBytes", optional: true },
        EXTENDEDERRORMESSAGE => { type: ::Thrift::Types::STRING, name: "extendedErrorMessage", optional: true },
        EXTENDEDERRORCODE => { type: ::Thrift::Types::STRING, name: "extendedErrorCode", optional: true },
        EXTENDEDERRORDETAILS => { type: ::Thrift::Types::MAP, name: "extendedErrorDetails", key: { type: ::Thrift::Types::STRING }, value: { type: ::Thrift::Types::STRING }, optional: true }
      }

      def struct_fields; FIELDS; end

      def validate
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, "Required field endTime is unset!") unless @endTime
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, "Required field startTime is unset!") unless @startTime
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, "Required field etag is unset!") unless @etag
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, "Required field httpStatusCode is unset!") unless @httpStatusCode
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, "Required field serviceRequestId is unset!") unless @serviceRequestId
        unless @targetLocation.nil? || ::XSS::AutoGenerated::StorageLocation::VALID_VALUES.include?(@targetLocation)
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, "Invalid value of field targetLocation!")
        end
      end

      ::Thrift::Struct.generate_accessors self
    end

    class OperationContext
      include ::Thrift::Struct, ::Thrift::Struct_Union
      CLIENTREQUESTID = 1
      USERHEADERS = 2
      REQUESTRESULTS = 3

      FIELDS = {
        CLIENTREQUESTID => { type: ::Thrift::Types::STRING, name: "clientRequestId" },
        USERHEADERS => { type: ::Thrift::Types::MAP, name: "userHeaders", key: { type: ::Thrift::Types::STRING }, value: { type: ::Thrift::Types::STRING }, optional: true },
        REQUESTRESULTS => { type: ::Thrift::Types::LIST, name: "requestResults", element: { type: ::Thrift::Types::STRUCT, class: ::XSS::AutoGenerated::RequestResult }, optional: true }
      }

      def struct_fields; FIELDS; end

      def validate
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, "Required field clientRequestId is unset!") unless @clientRequestId
      end

      ::Thrift::Struct.generate_accessors self
    end

    class InternalRequestInformation
      include ::Thrift::Struct, ::Thrift::Struct_Union
      URI = 1
      STATUSCODE = 2
      HTTPVERB = 3
      STATUSDESCRIPTION = 4
      RESPONSEHEADERS = 5
      REQUESTHEADERS = 6
      CLIENTREQUESTID = 7
      ENDTIME = 8
      STARTTIME = 9
      REQUESTRESULTS = 10
      CONTENTLENGTH = 11
      MEDIATYPE = 12

      FIELDS = {
        URI => { type: ::Thrift::Types::STRING, name: "uri" },
        STATUSCODE => { type: ::Thrift::Types::I32, name: "statusCode" },
        HTTPVERB => { type: ::Thrift::Types::STRING, name: "httpVerb" },
        STATUSDESCRIPTION => { type: ::Thrift::Types::STRING, name: "statusDescription" },
        RESPONSEHEADERS => { type: ::Thrift::Types::MAP, name: "responseHeaders", key: { type: ::Thrift::Types::STRING }, value: { type: ::Thrift::Types::STRING }, optional: true },
        REQUESTHEADERS => { type: ::Thrift::Types::MAP, name: "requestHeaders", key: { type: ::Thrift::Types::STRING }, value: { type: ::Thrift::Types::STRING }, optional: true },
        CLIENTREQUESTID => { type: ::Thrift::Types::STRING, name: "clientRequestId", optional: true },
        ENDTIME => { type: ::Thrift::Types::I64, name: "endTime", optional: true },
        STARTTIME => { type: ::Thrift::Types::I64, name: "startTime", optional: true },
        REQUESTRESULTS => { type: ::Thrift::Types::LIST, name: "requestResults", element: { type: ::Thrift::Types::STRUCT, class: ::XSS::AutoGenerated::RequestResult }, optional: true },
        CONTENTLENGTH => { type: ::Thrift::Types::I64, name: "contentLength", optional: true },
        MEDIATYPE => { type: ::Thrift::Types::STRING, name: "mediaType", optional: true }
      }

      def struct_fields; FIELDS; end

      def validate
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, "Required field uri is unset!") unless @uri
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, "Required field statusCode is unset!") unless @statusCode
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, "Required field httpVerb is unset!") unless @httpVerb
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, "Required field statusDescription is unset!") unless @statusDescription
      end

      ::Thrift::Struct.generate_accessors self
    end

    # This structure describes a set of storage credentials used to access
    # Azure Storage.
    #
    # These credentials can represent three different types of credentials
    # depending on the parameters passed to it.
    #
    # @param credentialsType
    #     A StorageCredentialsType that indicates how the credentials
    #     should be processed.
    #
    # @param accountName
    #     A string that represents the name of the storage account.
    #
    # @param base64EncodedKey
    #     A string that represents the Base64-encoded account access key.
    #
    # @param sasToken
    #     A string representing the shared access signature token.
    #
    # @param blobUri
    #     A string representing the base uri for blob operations
    #
    # @param tableUri
    #     A string representing the base uri for table operations
    #
    # @param queueUri
    #     A string representing the base uri for queue operations
    #
    # @param fileUri
    #     A string representing the base uri for file operations
    class StorageAccountInfo
      include ::Thrift::Struct, ::Thrift::Struct_Union
      CREDENTIALSTYPE = 1
      ACCOUNTNAME = 2
      BASE64ENCODEDKEY = 3
      SASTOKEN = 4
      BLOBURI = 5
      TABLEURI = 6
      QUEUEURI = 7
      FILEURI = 8

      FIELDS = {
        CREDENTIALSTYPE => { type: ::Thrift::Types::I32, name: "credentialsType", enum_class: ::XSS::AutoGenerated::StorageCredentialsType },
        ACCOUNTNAME => { type: ::Thrift::Types::STRING, name: "accountName", optional: true },
        BASE64ENCODEDKEY => { type: ::Thrift::Types::STRING, name: "base64EncodedKey", optional: true },
        SASTOKEN => { type: ::Thrift::Types::STRING, name: "sasToken", optional: true },
        BLOBURI => { type: ::Thrift::Types::STRUCT, name: "blobUri", class: ::XSS::AutoGenerated::CloudStorageUri, optional: true },
        TABLEURI => { type: ::Thrift::Types::STRUCT, name: "tableUri", class: ::XSS::AutoGenerated::CloudStorageUri, optional: true },
        QUEUEURI => { type: ::Thrift::Types::STRUCT, name: "queueUri", class: ::XSS::AutoGenerated::CloudStorageUri, optional: true },
        FILEURI => { type: ::Thrift::Types::STRUCT, name: "fileUri", class: ::XSS::AutoGenerated::CloudStorageUri, optional: true }
      }

      def struct_fields; FIELDS; end

      def validate
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, "Required field credentialsType is unset!") unless @credentialsType
        unless @credentialsType.nil? || ::XSS::AutoGenerated::StorageCredentialsType::VALID_VALUES.include?(@credentialsType)
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, "Invalid value of field credentialsType!")
        end
      end

      ::Thrift::Struct.generate_accessors self
    end

    class ThriftAccessCondition
      include ::Thrift::Struct, ::Thrift::Struct_Union
      LEASEID = 1
      IFMATCHETAG = 2
      IFNONEMATCHETAG = 3
      IFMODIFIEDSINCETIME = 4
      IFNOTMODIFIEDSINCETIME = 5
      IFSEQUENCENUMBEREQUAL = 6
      IFSEQUENCENUMBERLESSTHAN = 7
      IFSEQUENCENUMBERLESSTHANOREQUAL = 8

      FIELDS = {
        LEASEID => { type: ::Thrift::Types::STRING, name: "leaseId", optional: true },
        IFMATCHETAG => { type: ::Thrift::Types::STRING, name: "ifMatchEtag", optional: true },
        IFNONEMATCHETAG => { type: ::Thrift::Types::STRING, name: "ifNoneMatchEtag", optional: true },
        IFMODIFIEDSINCETIME => { type: ::Thrift::Types::I64, name: "ifModifiedSinceTime", optional: true },
        IFNOTMODIFIEDSINCETIME => { type: ::Thrift::Types::I64, name: "ifNotModifiedSinceTime", optional: true },
        IFSEQUENCENUMBEREQUAL => { type: ::Thrift::Types::I64, name: "ifSequenceNumberEqual", optional: true },
        IFSEQUENCENUMBERLESSTHAN => { type: ::Thrift::Types::I64, name: "ifSequenceNumberLessThan", optional: true },
        IFSEQUENCENUMBERLESSTHANOREQUAL => { type: ::Thrift::Types::I64, name: "ifSequenceNumberLessThanOrEqual", optional: true }
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    # This structure describes a language-agnostic storage exception
    class WrappedStorageException < ::Thrift::Exception
      include ::Thrift::Struct, ::Thrift::Struct_Union
      ERRORMESSAGE = 1
      ERRORCODE = 2
      HTTPSTATUSCODE = 3
      STORAGELOCATION = 4
      REQUESTDATE = 5
      ETAG = 6
      SERVICEREQUESTID = 7
      CONTENTMD5 = 8
      ADDITIONALDETAILS = 9
      PRESERVEDSTACKTRACE = 10
      EXCEPTIONMESSAGE = 11

      FIELDS = {
        ERRORMESSAGE => { type: ::Thrift::Types::STRING, name: "errorMessage" },
        ERRORCODE => { type: ::Thrift::Types::STRING, name: "errorCode" },
        HTTPSTATUSCODE => { type: ::Thrift::Types::I32, name: "httpStatusCode" },
        STORAGELOCATION => { type: ::Thrift::Types::I32, name: "storageLocation", optional: true, enum_class: ::XSS::AutoGenerated::StorageLocation },
        REQUESTDATE => { type: ::Thrift::Types::STRING, name: "requestDate", optional: true },
        ETAG => { type: ::Thrift::Types::STRING, name: "etag", optional: true },
        SERVICEREQUESTID => { type: ::Thrift::Types::STRING, name: "serviceRequestId", optional: true },
        CONTENTMD5 => { type: ::Thrift::Types::STRING, name: "contentMd5", optional: true },
        ADDITIONALDETAILS => { type: ::Thrift::Types::MAP, name: "additionalDetails", key: { type: ::Thrift::Types::STRING }, value: { type: ::Thrift::Types::STRING }, optional: true },
        PRESERVEDSTACKTRACE => { type: ::Thrift::Types::STRING, name: "preservedStackTrace", optional: true },
        EXCEPTIONMESSAGE => { type: ::Thrift::Types::STRING, name: "exceptionMessage", optional: true }
      }

      def struct_fields; FIELDS; end

      def validate
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, "Required field errorMessage is unset!") unless @errorMessage
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, "Required field errorCode is unset!") unless @errorCode
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, "Required field httpStatusCode is unset!") unless @httpStatusCode
        unless @storageLocation.nil? || ::XSS::AutoGenerated::StorageLocation::VALID_VALUES.include?(@storageLocation)
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, "Invalid value of field storageLocation!")
        end
      end

      ::Thrift::Struct.generate_accessors self
    end

    # string allowedMethods: is a comma separated string representation of the cors http methods
    # TODO: Replace it with enum set
    class CorsRule
      include ::Thrift::Struct, ::Thrift::Struct_Union
      MAXAGEINSECONDS = 1
      ALLOWEDHEADERS = 2
      ALLOWEDMETHODS = 3
      ALLOWEDORIGINS = 4
      EXPOSEDHEADERS = 5

      FIELDS = {
        MAXAGEINSECONDS => { type: ::Thrift::Types::I32, name: "maxAgeInSeconds" },
        ALLOWEDHEADERS => { type: ::Thrift::Types::LIST, name: "allowedHeaders", element: { type: ::Thrift::Types::STRING } },
        ALLOWEDMETHODS => { type: ::Thrift::Types::STRING, name: "allowedMethods" },
        ALLOWEDORIGINS => { type: ::Thrift::Types::LIST, name: "allowedOrigins", element: { type: ::Thrift::Types::STRING } },
        EXPOSEDHEADERS => { type: ::Thrift::Types::LIST, name: "exposedHeaders", element: { type: ::Thrift::Types::STRING } }
      }

      def struct_fields; FIELDS; end

      def validate
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, "Required field maxAgeInSeconds is unset!") unless @maxAgeInSeconds
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, "Required field allowedHeaders is unset!") unless @allowedHeaders
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, "Required field allowedMethods is unset!") unless @allowedMethods
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, "Required field allowedOrigins is unset!") unless @allowedOrigins
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, "Required field exposedHeaders is unset!") unless @exposedHeaders
      end

      ::Thrift::Struct.generate_accessors self
    end

    class MetricsProperties
      include ::Thrift::Struct, ::Thrift::Struct_Union
      METRICSLEVEL = 1
      VERSION = 2
      RETENTIONDAYS = 3

      FIELDS = {
        METRICSLEVEL => { type: ::Thrift::Types::I32, name: "metricsLevel", enum_class: ::XSS::AutoGenerated::MetricsLevel },
        VERSION => { type: ::Thrift::Types::STRING, name: "version" },
        RETENTIONDAYS => { type: ::Thrift::Types::I32, name: "retentionDays", optional: true }
      }

      def struct_fields; FIELDS; end

      def validate
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, "Required field metricsLevel is unset!") unless @metricsLevel
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, "Required field version is unset!") unless @version
        unless @metricsLevel.nil? || ::XSS::AutoGenerated::MetricsLevel::VALID_VALUES.include?(@metricsLevel)
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, "Invalid value of field metricsLevel!")
        end
      end

      ::Thrift::Struct.generate_accessors self
    end

    # string loggingOperations: is a comma separated string representation of the logging operations
    # TODO: Replace it with enum set
    class LoggingProperties
      include ::Thrift::Struct, ::Thrift::Struct_Union
      LOGGINGOPERATIONS = 1
      VERSION = 2
      RETENTIONDAYS = 3

      FIELDS = {
        LOGGINGOPERATIONS => { type: ::Thrift::Types::STRING, name: "loggingOperations" },
        VERSION => { type: ::Thrift::Types::STRING, name: "version" },
        RETENTIONDAYS => { type: ::Thrift::Types::I32, name: "retentionDays", optional: true }
      }

      def struct_fields; FIELDS; end

      def validate
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, "Required field loggingOperations is unset!") unless @loggingOperations
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, "Required field version is unset!") unless @version
      end

      ::Thrift::Struct.generate_accessors self
    end

    # A struct representing delete retention properties for soft delete
    class DeleteRetentionPolicyProperties
      include ::Thrift::Struct, ::Thrift::Struct_Union
      ENABLED = 1
      DAYS = 2
      RETAINEDVERSIONSPERBLOB = 3

      FIELDS = {
        ENABLED => { type: ::Thrift::Types::BOOL, name: "enabled" },
        DAYS => { type: ::Thrift::Types::I32, name: "days", optional: true },
        RETAINEDVERSIONSPERBLOB => { type: ::Thrift::Types::I32, name: "retainedVersionsPerBlob", optional: true }
      }

      def struct_fields; FIELDS; end

      def validate
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, "Required field enabled is unset!") if @enabled.nil?
      end

      ::Thrift::Struct.generate_accessors self
    end

    class ThriftStorageServiceProperties
      include ::Thrift::Struct, ::Thrift::Struct_Union
      CORSRULES = 1
      DEFAULTSERVICEVERSION = 2
      LOGGING = 3
      MINUTEMETRICS = 4
      HOURMETRICS = 5
      DELETERETENTIONPROPERTIES = 6

      FIELDS = {
        CORSRULES => { type: ::Thrift::Types::LIST, name: "corsRules", element: { type: ::Thrift::Types::STRUCT, class: ::XSS::AutoGenerated::CorsRule }, optional: true },
        DEFAULTSERVICEVERSION => { type: ::Thrift::Types::STRING, name: "defaultServiceVersion", optional: true },
        LOGGING => { type: ::Thrift::Types::STRUCT, name: "logging", class: ::XSS::AutoGenerated::LoggingProperties, optional: true },
        MINUTEMETRICS => { type: ::Thrift::Types::STRUCT, name: "minuteMetrics", class: ::XSS::AutoGenerated::MetricsProperties, optional: true },
        HOURMETRICS => { type: ::Thrift::Types::STRUCT, name: "hourMetrics", class: ::XSS::AutoGenerated::MetricsProperties, optional: true },
        DELETERETENTIONPROPERTIES => { type: ::Thrift::Types::STRUCT, name: "deleteRetentionProperties", class: ::XSS::AutoGenerated::DeleteRetentionPolicyProperties, optional: true }
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class GeoReplicationStats
      include ::Thrift::Struct, ::Thrift::Struct_Union
      STATUS = 1
      LASTSYNCTIME = 2

      FIELDS = {
        STATUS => { type: ::Thrift::Types::I32, name: "status", enum_class: ::XSS::AutoGenerated::GeoReplicationStatus },
        LASTSYNCTIME => { type: ::Thrift::Types::I64, name: "lastSyncTime", optional: true }
      }

      def struct_fields; FIELDS; end

      def validate
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, "Required field status is unset!") unless @status
        unless @status.nil? || ::XSS::AutoGenerated::GeoReplicationStatus::VALID_VALUES.include?(@status)
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, "Invalid value of field status!")
        end
      end

      ::Thrift::Struct.generate_accessors self
    end

    class ThriftServiceStats
      include ::Thrift::Struct, ::Thrift::Struct_Union
      GEOREPLICATION = 1

      FIELDS = {
        GEOREPLICATION => { type: ::Thrift::Types::STRUCT, name: "geoReplication", class: ::XSS::AutoGenerated::GeoReplicationStats }
      }

      def struct_fields; FIELDS; end

      def validate
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, "Required field geoReplication is unset!") unless @geoReplication
      end

      ::Thrift::Struct.generate_accessors self
    end

    class ThriftCopyState
      include ::Thrift::Struct, ::Thrift::Struct_Union
      BYTESCOPIED = 1
      COMPLETIONTIME = 2
      COPYID = 3
      URI = 4
      COPYSTATUS = 5
      STATUSDESCRIPTION = 6
      TOTALBYTE = 7
      COPYDESTINATIONSNAPSHOTID = 8

      FIELDS = {
        BYTESCOPIED => { type: ::Thrift::Types::I64, name: "bytesCopied", optional: true },
        COMPLETIONTIME => { type: ::Thrift::Types::I64, name: "completionTime", optional: true },
        COPYID => { type: ::Thrift::Types::STRING, name: "copyID", optional: true },
        URI => { type: ::Thrift::Types::STRUCT, name: "uri", class: ::XSS::AutoGenerated::CloudStorageUri, optional: true },
        COPYSTATUS => { type: ::Thrift::Types::I32, name: "copyStatus", optional: true, enum_class: ::XSS::AutoGenerated::ThriftCopyStatus },
        STATUSDESCRIPTION => { type: ::Thrift::Types::STRING, name: "statusDescription", optional: true },
        TOTALBYTE => { type: ::Thrift::Types::I64, name: "totalByte", optional: true },
        COPYDESTINATIONSNAPSHOTID => { type: ::Thrift::Types::STRING, name: "copyDestinationSnapshotID", optional: true }
      }

      def struct_fields; FIELDS; end

      def validate
        unless @copyStatus.nil? || ::XSS::AutoGenerated::ThriftCopyStatus::VALID_VALUES.include?(@copyStatus)
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, "Invalid value of field copyStatus!")
        end
      end

      ::Thrift::Struct.generate_accessors self
    end
  end
end
