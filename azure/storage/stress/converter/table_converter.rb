require "azure/storage"
require "base64"
require_relative "core_converter"
require_relative "../infrastructure/logging_aspect"


module Azure::Storage::Stress
  module Converter
    class TableConverter
      def self.getTableService(handler, accountInfo, filters = [])
        storageService = XSS::Converter::CoreConverter.getStorageService(handler, accountInfo)
        table_client = storageService.table_client
        filters.each { |filter| table_client.with_filter(filter) }
        table_client
      end

      def self.getStorageEntityFromThriftOperation(thriftOperation)
        options = {}
        unless thriftOperation.nil?
          options[:PartitionKey] = thriftOperation.entity.partitionKey
          options[:RowKey] = thriftOperation.entity.rowKey
          thriftOperation.entity.properties.each do |key, property|
            type = "Edm." + XSS::Utilities::getConstNameFromModule(XSS::AutoGenerated::ThriftEdmType, property.propertyType) unless property.isNull
            options[key] = property.isNull ? nil : Azure::Storage::Table::EdmType.deserialize_value(property.value, type)
          end if thriftOperation.entity.properties
        end
        options
      end

      def self.getThriftEntityFromStorageEntity(storageEntity)
        return nil if storageEntity.nil?

        entity = XSS::AutoGenerated::ThriftTableEntity.new
        entity.properties = {}
        entity.etag = storageEntity.etag
        storageEntity.properties.each do |key, value|
          if key.to_s == "PartitionKey"
            entity.partitionKey = value
          elsif key.to_s == "RowKey"
            entity.rowKey = value
          else
            property = XSS::AutoGenerated::ThriftEntityProperty.new
            propertyType = Azure::Storage::Table::EdmType.property_type(value)
            property.propertyType = XSS::Utilities::thriftizeString(XSS::AutoGenerated::ThriftEdmType, propertyType.sub("Edm.", ""))
            property.isNull = value.nil?
            property.value =
              case property.propertyType
              when XSS::AutoGenerated::ThriftEdmType::Binary
                Base64::strict_encode64(value)
              when XSS::AutoGenerated::ThriftEdmType::DateTime
                XSS::Utilities::datetimeToEdmString(value)
              else
                value.to_s
              end unless value.nil?
            property.value = "" if value.nil?
            entity.properties[key.to_s] = property
          end
        end
        entity
      end

      def self.getStorageBatchFromThriftOperations(tableName, thriftOperations, reqOptions)
        batch = nil

        thriftOperations.each do |operation|
          if batch.nil?
            batch = Azure::Storage::Table::Batch.new(tableName, operation.entity.partitionKey)
          end

          entity = getStorageEntityFromThriftOperation(operation)

          LoggingAspect::logger.info("Create batch operation #{operation.operationType.to_s}")
          LoggingAspect::logger.debug("entity is #{entity.inspect}")

          case operation.operationType
          when XSS::AutoGenerated::ThriftTableOperationType::Insert
            batch.insert(operation.entity.rowKey, entity, reqOptions)
          when XSS::AutoGenerated::ThriftTableOperationType::Delete
            batch.delete(operation.entity.rowKey, reqOptions)
          when XSS::AutoGenerated::ThriftTableOperationType::Replace
            batch.update(operation.entity.rowKey, reqOptions)
          when XSS::AutoGenerated::ThriftTableOperationType::Merge
            batch.merge(operation.entity.rowKey, entity, reqOptions)
          when XSS::AutoGenerated::ThriftTableOperationType::InsertOrReplace
            batch.insert_or_replace(operation.entity.rowKey, entity)
          when XSS::AutoGenerated::ThriftTableOperationType::InsertOrMerge
            batch.insert_or_merge(operation.entity.rowKey, entity)
          end
        end
        batch
      end

      def self.getStorageQueryFromThriftQuery(tableQuery, continuationToken)
        query = []

        unless continuationToken.nil?
          query[:continuation_token] = {}
          query[:continuation_token][:next_partition_key] = continuationToken.nextPartitionKey
          query[:continuation_token][:next_row_key] = continuationToken.nextRowKey
        end

        query[:filter] = tableQuery.filterString unless tableQuery.filterString.nil?
        query[:top] = tableQuery.takeCount unless tableQuery.takeCount.nil?
        unless tableQuery.selectColumns.nil?
          query[:select] = []
          tableQuery.selectColumns.each do |select|
            query[:select].push(select)
          end
        end
        query
      end
    end
  end
end
