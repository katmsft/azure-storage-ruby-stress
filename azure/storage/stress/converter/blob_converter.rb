require "azure/storage"
require_relative "core_converter"
require_relative "../infrastructure/logging_aspect"
require_relative "../auto_generated/blob_types_types"
require_relative "../utils"


module Azure::Storage::Stress
  module Converter
    class BlobConverter
      def self.getBlobService(handler, accountInfo, filters = [])
        storageService = XSS::Converter::CoreConverter.getStorageService(handler, accountInfo)
        blob_client = storageService.blob_client
        filters.each { |filter| blob_client.with_filter(filter) }
        blob_client
      end

      def self.getRequestOptions(thriftBlobRequestOptions)
        # TODO: DisableContentMD5Validation, maximumExecutionTimeSeconds, singleBlobUploadThresholdBytes, storeBlobContentMD5, useTransactionalMD5, absorbConditionalErrorsOnRetry, parallelOperationThreadCount
        options = XSS::Converter::CoreConverter::getRequestOptions(thriftBlobRequestOptions)
      end

      def self.buildCloudBlobResponseFromInternalRequestInfo(rInfo)
        result = XSS::AutoGenerated::CloudBlobResponse.new

        result.etag = rInfo.responseHeaders["etag"] unless rInfo.responseHeaders["etag"].nil?

        result.lastModified = XSS::Utilities::timeStringToInteger(rInfo.responseHeaders["last-modified"]) unless rInfo.responseHeaders["last-modified"].nil?

        result.metadata = XSS::Utilities::metadataFromHeaders(rInfo.responseHeaders)

        result.leaseStatus = XSS::Utilities::thriftizeString(XSS::AutoGenerated::LeaseStatus, rInfo.responseHeaders["x-ms-lease-status"])

        result.leaseState = XSS::Utilities::thriftizeString(XSS::AutoGenerated::LeaseState, rInfo.responseHeaders["x-ms-lease-state"])

        result.leaseDuration = XSS::Utilities::thriftizeString(XSS::AutoGenerated::LeaseDuration, rInfo.responseHeaders["x-ms-lease-duration"])

        cacheControl = rInfo.responseHeaders["x-ms-blob-cache-control"] || rInfo.responseHeaders["cache-control"]
        result.cacheControl = cacheControl unless cacheControl.nil? || cacheControl.empty?

        contentDisposition = rInfo.responseHeaders["x-ms-blob-content-disposition"] || rInfo.responseHeaders["Content-Disposition"]
        result.contentDisposition = contentDisposition unless contentDisposition.nil? || contentDisposition.empty?

        contentEncoding = rInfo.responseHeaders["x-ms-blob-content-encoding"] || rInfo.responseHeaders["Content-Encoding"]
        result.contentEncoding = contentEncoding unless contentEncoding.nil? || contentEncoding.empty?

        contentLanguage = rInfo.responseHeaders["x-ms-blob-content-language"] || rInfo.responseHeaders["Content-Language"]
        result.contentLanguage = contentLanguage unless contentLanguage.nil? || contentLanguage.empty?

        length = rInfo.responseHeaders["x-ms-blob-content-length"] || rInfo.responseHeaders["Content-Length"]
        result.length = length.to_i unless length.nil? || length.empty?

        contentMd5 = rInfo.responseHeaders["x-ms-blob-content-md5"] || rInfo.responseHeaders["Content-MD5"]
        result.contentMd5 = contentMd5 unless contentMd5.nil? || contentMd5.empty?

        contentType = rInfo.responseHeaders["x-ms-blob-content-type"] || rInfo.responseHeaders["Content-Type"]
        result.contentType = contentType unless contentType.nil? || contentType.empty?

        result.blobType = XSS::Utilities::thriftizeString(XSS::AutoGenerated::BlobType, rInfo.responseHeaders["x-ms-blob-type"])

        result.PageBlobSequenceNumber = rInfo.responseHeaders["x-ms-blob-sequence-number"].to_i if rInfo.responseHeaders["x-ms-blob-sequence-number"]

        result.snapshotTime = XSS::Utilities::timeStringToInteger(rInfo.responseHeaders["x-ms-snapshot"]) unless rInfo.responseHeaders["x-ms-snapshot"].nil?

        result.copyState = XSS::Converter::CoreConverter::getCopyStateFromInternalRequestInfo(rInfo)

        result.isIncrementalCopy = rInfo.responseHeaders["x-ms-incremental-copy"].to_s == "true" unless rInfo.responseHeaders["x-ms-incremental-copy"].nil?

        # TODO: 2017-04-17
        # result.standardBlobTier
        # result.premiumPageBlobTier
        # result.rehydrationStatus
        # result.blobTierInferred

        # TODO: Soft delete
        # result.isSnapshot
        # result.isDeleted
        # result.deletedTime

        result
      end

      def self.buildBlobContainerResponseFromInternalRequestInfo(rInfo)
        result = XSS::AutoGenerated::BlobContainerResponse.new

        result.etag = rInfo.responseHeaders["etag"] unless rInfo.responseHeaders["etag"].nil?

        result.lastModified = XSS::Utilities::timeStringToInteger(rInfo.responseHeaders["last-modified"]) unless rInfo.responseHeaders["last-modified"].nil?

        result.metadata = XSS::Utilities::metadataFromHeaders(rInfo.responseHeaders)

        result.leaseStatus = XSS::Utilities::thriftizeString(XSS::AutoGenerated::LeaseStatus, rInfo.responseHeaders["x-ms-lease-status"])

        result.leaseState = XSS::Utilities::thriftizeString(XSS::AutoGenerated::LeaseState, rInfo.responseHeaders["x-ms-lease-state"])

        result.leaseDuration = XSS::Utilities::thriftizeString(XSS::AutoGenerated::LeaseDuration, rInfo.responseHeaders["x-ms-lease-duration"])

        result.publicAccessType = XSS::Utilities::thriftizeString(XSS::AutoGenerated::BlobContainerPublicAccessType, rInfo.responseHeaders["x-ms-blob-public-access"])

        result
      end

      def self.getAccessTypeFromBlobContainerPublicAccessType(accessType)
        case accessType
        when XSS::AutoGenerated::BlobContainerPublicAccessType::Container
          "container"
        when XSS::AutoGenerated::BlobContainerPublicAccessType::Blob
          "blob"
        else
          nil
        end
      end

      def self.convertSequenceNumberAction(sequenceNumberAction)
        case sequenceNumberAction
        when XSS::AutoGenerated::SequenceNumberAction::Increment
          :increment
        when XSS::AutoGenerated::SequenceNumberAction::Max
          :max
        when XSS::AutoGenerated::SequenceNumberAction::Update
          :update
        else
          nil
        end
      end

      def self.buildPageRangesFromListRangeResult(listResult)
        result = []
        listResult.each { |range|
          thriftRange = XSS::AutoGenerated::ThriftPageRange.new
          thriftRange.startOffset = range[0]
          thriftRange.endOffset = range[1]
          result.push thriftRange
        }
        result
      end

      def self.getBlobContinuationToken(nextMarker, uri)
        r = XSS::AutoGenerated::ThriftBlobContinuationToken.new
        r.targetLocation = uri.to_s.include?("-secondary") ? XSS::AutoGenerated::StorageLocation::Secondary : XSS::AutoGenerated::StorageLocation::Primary
        r.nextMarker = nextMarker
        r
      end
    end
  end
end
