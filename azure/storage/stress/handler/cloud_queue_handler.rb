require_relative "base_handler"
require_relative "../utils"
require_relative "cloud_queue_base_handler"
require_relative "../auto_generated/cloud_queue_service"
require_relative "../converter/core_converter"
require_relative "../converter/queue_converter"
require_relative "../infrastructure/logging_aspect"

module Azure::Storage::Stress
  module Handler
    class CloudQueueHandler < CloudQueueBaseHandler
      def create(requestInfo, accountInfo, createIfNotExists, metadata)
        # If queue already exists, return response from self.exists
        if createIfNotExists
          exists = self.exists(requestInfo, accountInfo)
          if (exists.exists)
            result = XSS::AutoGenerated::CreateQueueResponse.new
            result.created = false
            result.response = exists.response
            LoggingAspect::info("Queue #{requestInfo.queueName} already exists.")
            return result
          end
        end
        # ==== Build Client ==== #
        @request_info = XSS::Utilities::get_default_request_info
        queueClient = self.build_client(@request_info, accountInfo)
        # ==== Construct Parameters ==== #
        queueName = requestInfo.queueName
        reqOptions = XSS::Converter::CoreConverter.getRequestOptions(requestInfo.thriftRequestOptions)
        reqOptions.merge! XSS::Converter::CoreConverter::getOperationContextOptions(requestInfo.thriftOperationContext)
        reqOptions[:metadata] = metadata unless metadata.nil?
        LoggingAspect::info("Creating queue #{queueName}")
        LoggingAspect::debug("'options' is #{reqOptions.to_s}")
        result = queueClient.create_queue(queueName, reqOptions)
        # ==== Construct Return Value ==== #
        LoggingAspect::info("Creating queue #{queueName} successful")
        r = XSS::AutoGenerated::CreateQueueResponse.new
        r.created = true # successfully created at this point.
        r.response = XSS::Converter::QueueConverter::buildCloudQueueResponseFromInternalRequestInfo(@request_info, queueName)
        r
      end

      def deleteQueue(requestInfo, accountInfo, deleteIfExists)
        # If queue does not exist, return success
        if deleteIfExists
          exists = self.exists(requestInfo, accountInfo)
          unless (exists.exists)
            return true
          end
        end
        # ==== Build Client ==== #
        @request_info = XSS::Utilities::get_default_request_info
        queueClient = self.build_client(@request_info, accountInfo)
        # ==== Construct Parameters ==== #
        queueName = requestInfo.queueName
        reqOptions = XSS::Converter::CoreConverter.getRequestOptions(requestInfo.thriftRequestOptions)
        reqOptions.merge! XSS::Converter::CoreConverter::getOperationContextOptions(requestInfo.thriftOperationContext)
        LoggingAspect::info("Deleting queue #{queueName}")
        LoggingAspect::debug("'options' is #{reqOptions.to_s}")
        result = queueClient.delete_queue(queueName, reqOptions)
        # ==== Construct Return Value ==== #
        LoggingAspect::info("Deleting queue #{queueName} successful")
        # ==== Construct Return Value ==== #
        true # successfully deleted at this point.
      end

      def exists(requestInfo, accountInfo)
        # ==== Build Client ==== #
        @request_info = XSS::Utilities::get_default_request_info
        queueClient = self.build_client(@request_info, accountInfo)
        # ==== Construct Parameters ==== #
        queueName = requestInfo.queueName
        reqOptions = XSS::Converter::CoreConverter.getRequestOptions(requestInfo.thriftRequestOptions)
        reqOptions.merge! XSS::Converter::CoreConverter::getOperationContextOptions(requestInfo.thriftOperationContext)
        reqOptions[:prefix] = queueName
        # ==== Operation ==== #
        LoggingAspect::info("Trying to get if queue #{queueName} exists")
        LoggingAspect::debug("'options' is #{reqOptions.to_s}")
        temp = queueClient.list_queues(reqOptions)

        # ==== Construct Return Value ==== #
        LoggingAspect::info("Trying to get if queue #{queueName} exists successful")
        result = XSS::AutoGenerated::QueueExistsResponse.new
        result.exists = (!temp.empty?) && (temp.detect { |queue| queue.name == queueName })
        result.response = XSS::Converter::QueueConverter::buildCloudQueueResponseFromInternalRequestInfo(@request_info, queueName)
        result
      end

      def clearMessages(requestInfo, accountInfo)
        # ==== Build Client ==== #
        @request_info = XSS::Utilities::get_default_request_info
        queueClient = self.build_client(@request_info, accountInfo)
        # ==== Construct Parameters ==== #
        queueName = requestInfo.queueName
        reqOptions = XSS::Converter::CoreConverter.getRequestOptions(requestInfo.thriftRequestOptions)
        reqOptions.merge! XSS::Converter::CoreConverter::getOperationContextOptions(requestInfo.thriftOperationContext)

        # ==== Operation ==== #
        # retry?
        LoggingAspect::info("Clearing messages for queue #{queueName}")
        LoggingAspect::debug("'options' is #{reqOptions.to_s}")
        temp = queueClient.clear_messages(queueName, reqOptions)
        LoggingAspect::info("Clearing messages for queue #{queueName} successful")
        # ==== Construct Return Value ==== #
        nil
      end

      def fetchAttributes(requestInfo, accountInfo)
        # ==== Build Client ==== #
        @request_info = XSS::Utilities::get_default_request_info
        queueClient = self.build_client(@request_info, accountInfo)
        # ==== Construct Parameters ==== #
        queueName = requestInfo.queueName
        reqOptions = XSS::Converter::CoreConverter.getRequestOptions(requestInfo.thriftRequestOptions)
        reqOptions.merge! XSS::Converter::CoreConverter::getOperationContextOptions(requestInfo.thriftOperationContext)

        # ==== Operation ==== #
        LoggingAspect::info("Fetching attributes for queue #{queueName}")
        LoggingAspect::debug("'options' is #{reqOptions.to_s}")
        temp = queueClient.get_queue_metadata(queueName, reqOptions)

        # ==== Construct Return Value ==== #
        LoggingAspect::info("Fetching attributes for queue #{queueName} successful")
        result = XSS::Converter::QueueConverter::buildCloudQueueResponseFromInternalRequestInfo(@request_info, queueName)
        result.metadata = temp[1]
        result.ApproximateMessageCount = temp[0]
        result
      end

      def setMetadata(requestInfo, accountInfo, metadata)
        # ==== Build Client ==== #
        @request_info = XSS::Utilities::get_default_request_info
        queueClient = self.build_client(@request_info, accountInfo)
        # ==== Construct Parameters ==== #
        queueName = requestInfo.queueName
        reqOptions = XSS::Converter::CoreConverter.getRequestOptions(requestInfo.thriftRequestOptions)
        reqOptions.merge! XSS::Converter::CoreConverter::getOperationContextOptions(requestInfo.thriftOperationContext)

        # ==== Operation ==== #
        LoggingAspect::info("Setting metadata for queue #{queueName}")
        LoggingAspect::debug("'options' is #{reqOptions.to_s}")
        LoggingAspect::debug("'metadata' is #{metadata.to_s}")
        temp = queueClient.set_queue_metadata(queueName, metadata, reqOptions)

        # ==== Construct Return Value ==== #
        LoggingAspect::info("Setting metadata for queue #{queueName} successful")
        nil
      end

      def addMessage(addMessagePayload, accountInfo)
        # ==== Build Client ==== #
        @request_info = XSS::Utilities::get_default_request_info
        queueClient = self.build_client(@request_info, accountInfo)
        # ==== Construct Parameters ==== #
        requestInfo = addMessagePayload.requestInfo
        queueName = requestInfo.queueName
        reqOptions = XSS::Converter::CoreConverter.getRequestOptions(requestInfo.thriftRequestOptions)
        reqOptions.merge! XSS::Converter::CoreConverter::getOperationContextOptions(requestInfo.thriftOperationContext)
        messageText = addMessagePayload.payload
        reqOptions[:visibility_timeout] = XSS::Utilities::timeSpanToSecond(addMessagePayload.initialVisibilityDelay) unless addMessagePayload.initialVisibilityDelay < 0
        reqOptions[:message_ttl] = XSS::Utilities::timeSpanToSecond(addMessagePayload.timeToLive)  unless addMessagePayload.timeToLive < 0
        reqOptions[:encode] = true #encode message text
        reqOptions[:decode] = true
        # ==== Operation ==== #
        LoggingAspect::info("Creating message in queue #{queueName}")
        LoggingAspect::debug("'options' is #{reqOptions.to_s}")
        LoggingAspect::debug("'messageText' is #{messageText}")
        temp = queueClient.create_message(queueName, messageText, reqOptions)

        # ==== Construct Return Value ==== #
        LoggingAspect::info("Creating message in queue #{queueName} successful")
        result = XSS::AutoGenerated::CreateMessageResponse.new
        unless temp.empty?
          result.messageId = temp[0].id
          result.popReceipt = temp[0].pop_receipt
          result.insertionTime = XSS::Utilities::timeStringToInteger(temp[0].insertion_time)
          result.expirationTime = XSS::Utilities::timeStringToInteger(temp[0].expiration_time)
          result.nextVisibleTime = XSS::Utilities::timeStringToInteger(temp[0].time_next_visible)
        end
        result
      end

      def updateMessage(updateMessagePayload, accountInfo, visibilityTimeout, updateFields)
        # ==== Build Client ==== #
        @request_info = XSS::Utilities::get_default_request_info
        queueClient = self.build_client(@request_info, accountInfo)
        # ==== Construct Parameters ==== #
        requestInfo = updateMessagePayload.requestInfo
        queueName = requestInfo.queueName
        reqOptions = XSS::Converter::CoreConverter.getRequestOptions(requestInfo.thriftRequestOptions)
        reqOptions.merge! XSS::Converter::CoreConverter::getOperationContextOptions(requestInfo.thriftOperationContext)
        reqOptions[:encode] = true #encode message text
        reqOptions[:decode] = true
        messageId = updateMessagePayload.messageId
        popReceipt = updateMessagePayload.popReceipt
        messageText = updateMessagePayload.content
        visibilityTimeout = visibilityTimeout < 0 ? nil : XSS::Utilities::timeSpanToSecond(visibilityTimeout)

        # ==== Operation ==== #
        LoggingAspect::info("Updating message in queue #{queueName}")
        LoggingAspect::debug("'options' is #{reqOptions.to_s}")
        LoggingAspect::debug("'messageText' is #{messageText}")
        LoggingAspect::debug("'popReceipt' is #{popReceipt}")
        LoggingAspect::debug("'visibilityTimeout' is #{visibilityTimeout}")
        temp = queueClient.update_message(queueName, messageId, popReceipt, messageText, visibilityTimeout, reqOptions)

        # ==== Construct Return Value ==== #
        LoggingAspect::info("Updating message in queue #{queueName} successful")
        result = XSS::AutoGenerated::UpdateMessageResponse.new
        result.popReceipt = temp[0]
        result.nextVisibleTime = XSS::Utilities::timeStringToInteger(temp[1])
        result
      end

      def getMessage(requestInfo, accountInfo, visibilityTimeout)
        # ==== Build Client ==== #
        @request_info = XSS::Utilities::get_default_request_info
        queueClient = self.build_client(@request_info, accountInfo)
        # ==== Construct Parameters ==== #
        queueName = requestInfo.queueName
        visibilityTimeout = visibilityTimeout < 0 ? nil : XSS::Utilities::timeSpanToSecond(visibilityTimeout)
        reqOptions = XSS::Converter::CoreConverter.getRequestOptions(requestInfo.thriftRequestOptions)
        reqOptions.merge! XSS::Converter::CoreConverter::getOperationContextOptions(requestInfo.thriftOperationContext)
        reqOptions[:decode] = true
        # ==== Operation ==== #
        LoggingAspect::info("Getting message from queue #{queueName}")
        LoggingAspect::debug("'options' is #{reqOptions.to_s}")
        LoggingAspect::debug("'visibilityTimeout' is #{visibilityTimeout.to_s}")
        temp = queueClient.list_messages(queueName, visibilityTimeout, reqOptions)

        # ==== Construct Return Value ==== #
        LoggingAspect::info("Getting message from queue #{queueName} successful")
        XSS::Converter::QueueConverter.convertQueueMessageToThriftQueueMessage(temp[0])
      end

      def peekMessage(requestInfo, accountInfo)
        # ==== Build Client ==== #
        @request_info = XSS::Utilities::get_default_request_info
        queueClient = self.build_client(@request_info, accountInfo)
        # ==== Construct Parameters ==== #
        queueName = requestInfo.queueName
        reqOptions = XSS::Converter::CoreConverter.getRequestOptions(requestInfo.thriftRequestOptions)
        reqOptions.merge! XSS::Converter::CoreConverter::getOperationContextOptions(requestInfo.thriftOperationContext)
        reqOptions[:decode] = true
        # ==== Operation ==== #
        LoggingAspect::info("Peeking message from queue #{queueName}")
        LoggingAspect::debug("'options' is #{reqOptions.to_s}")
        temp = queueClient.peek_messages(queueName, reqOptions)

        # ==== Construct Return Value ==== #
        LoggingAspect::info("Peeking message from queue #{queueName} successful")
        XSS::Converter::QueueConverter.convertQueueMessageToThriftQueueMessage(temp[0])
      end

      def getMessages(requestInfo, accountInfo, visibilityTimeout, messageCount)
        # ==== Build Client ==== #
        @request_info = XSS::Utilities::get_default_request_info
        queueClient = self.build_client(@request_info, accountInfo)
        # ==== Construct Parameters ==== #
        queueName = requestInfo.queueName
        visibilityTimeout = visibilityTimeout < 0 ? nil : XSS::Utilities::timeSpanToSecond(visibilityTimeout)
        reqOptions = XSS::Converter::CoreConverter.getRequestOptions(requestInfo.thriftRequestOptions)
        reqOptions.merge! XSS::Converter::CoreConverter::getOperationContextOptions(requestInfo.thriftOperationContext)
        reqOptions[:number_of_messages] = messageCount
        reqOptions[:decode] = true
        # ==== Operation ==== #
        LoggingAspect::info("Getting messages from queue #{queueName}")
        LoggingAspect::debug("'options' is #{reqOptions.to_s}")
        temp = queueClient.list_messages(queueName, visibilityTimeout, reqOptions)

        # ==== Construct Return Value ==== #
        LoggingAspect::info("Getting messages from queue #{queueName} successful")
        result = []
        temp.each do |message|
          entry = XSS::Converter::QueueConverter.convertQueueMessageToThriftQueueMessage(message)
          result.push(entry)
        end
        result
      end

      def peekMessages(requestInfo, accountInfo, messageCount)
        # ==== Build Client ==== #
        @request_info = XSS::Utilities::get_default_request_info
        queueClient = self.build_client(@request_info, accountInfo)
        # ==== Construct Parameters ==== #
        queueName = requestInfo.queueName
        reqOptions = XSS::Converter::CoreConverter.getRequestOptions(requestInfo.thriftRequestOptions)
        reqOptions.merge! XSS::Converter::CoreConverter::getOperationContextOptions(requestInfo.thriftOperationContext)
        reqOptions[:number_of_messages] = messageCount
        reqOptions[:decode] = true
        # ==== Operation ==== #
        LoggingAspect::info("Peeking messages from queue #{queueName}")
        LoggingAspect::debug("'options' is #{reqOptions.to_s}")
        temp = queueClient.peek_messages(queueName, reqOptions)

        # ==== Construct Return Value ==== #
        LoggingAspect::info("Peeking messages from queue #{queueName} successful")
        result = []
        temp.each do |message|
          entry = XSS::Converter::QueueConverter.convertQueueMessageToThriftQueueMessage(message)
          result.push(entry)
        end
        return result
      end

      def deleteMessage(requestInfo, accountInfo, messageId, popReceipt)
        # ==== Build Client ==== #
        @request_info = XSS::Utilities::get_default_request_info
        queueClient = self.build_client(@request_info, accountInfo)
        # ==== Construct Parameters ==== #
        queueName = requestInfo.queueName
        messageId = messageId
        popReceipt = popReceipt
        reqOptions = XSS::Converter::CoreConverter.getRequestOptions(requestInfo.thriftRequestOptions)
        reqOptions.merge! XSS::Converter::CoreConverter::getOperationContextOptions(requestInfo.thriftOperationContext)

        # ==== Operation ==== #
        LoggingAspect::info("Deleting messages from queue #{queueName}")
        LoggingAspect::debug("'options' is #{reqOptions.to_s}")
        LoggingAspect::debug("'messageId' is #{messageId}")
        LoggingAspect::debug("'popReceipt' is #{popReceipt}")
        queueClient.delete_message(queueName, messageId, popReceipt, reqOptions)

        # ==== Construct Return Value ==== #
        LoggingAspect::info("Deleting messages from queue #{queueName} successful")
      end

      def setPermissions(requestInfo, accountInfo, permissions)
        # ==== Build Client ==== #
        @request_info = XSS::Utilities::get_default_request_info
        queueClient = self.build_client(@request_info, accountInfo)
        # ==== Construct Parameters ==== #
        queueName = requestInfo.queueName
        reqOptions = XSS::Converter::CoreConverter.getRequestOptions(requestInfo.thriftRequestOptions)
        reqOptions.merge! XSS::Converter::CoreConverter::getOperationContextOptions(requestInfo.thriftOperationContext)
        reqOptions[:signed_identifiers] = XSS::Converter::CoreConverter::getSignedIdentifiersFromThriftSharedAccessPolicies(permissions)

        # ==== Operation ==== #
        LoggingAspect::info("Setting acl for queue #{queueName}")
        LoggingAspect::debug("'options' is #{reqOptions.to_s}")
        queueClient.set_queue_acl(queueName, reqOptions)

        # ==== Construct Return Value ==== #
        LoggingAspect::info("Setting acl for queue #{queueName} successful")
      end

      def getPermissions(requestInfo, accountInfo)
        # ==== Build Client ==== #
        @request_info = XSS::Utilities::get_default_request_info
        queueClient = self.build_client(@request_info, accountInfo)
        # ==== Construct Parameters ==== #
        queueName = requestInfo.queueName
        reqOptions = XSS::Converter::CoreConverter.getRequestOptions(requestInfo.thriftRequestOptions)
        reqOptions.merge! XSS::Converter::CoreConverter::getOperationContextOptions(requestInfo.thriftOperationContext)

        # ==== Operation ==== #
        LoggingAspect::info("Getting acl for queue #{queueName}")
        LoggingAspect::debug("'options' is #{reqOptions.to_s}")
        result = queueClient.get_queue_acl(queueName, reqOptions)

        # ==== Construct Return Value ==== #
        LoggingAspect::info("Getting acl for queue #{queueName} successful")
        XSS::Converter::CoreConverter::getThriftSharedAccessPoliciesFromSignedIdentifiers(result, XSS::AutoGenerated::ThriftSharedAccessQueuePolicy)
      end
    end
  end
end
