require_relative "base_handler"
require_relative "../utils"
require_relative "../auto_generated/cloud_queue_service"
require_relative "../converter/core_converter"
require_relative "../converter/queue_converter"
require_relative "../infrastructure/logging_aspect"

# TODO: setPermission cannot run
# TODO: time needs to be converted

module Azure::Storage::Stress
  module Handler
    class CloudQueueHandler < BaseHandler
      def create(requestInfo, accountInfo, createIfNotExists, metadata)
        # If queue already exists, return response from self.exists
        if createIfNotExists
          exists = self.exists(requestInfo, accountInfo)
          if (exists.exists)
            result = XSS::AutoGenerated::CreateQueueResponse.new
            result.created = false
            result.response = exists.response
            LoggingAspect::logger.info("Queue #{requestInfo.queueName} already exists.")
            return result
          end
        end
        # ==== Build Client ==== #
        internalRequestInfo = XSS::Utilities::get_default_request_info
        queueClient = self.build_client(internalRequestInfo, accountInfo, XSS::Converter::QueueConverter.getQueueService)
        # ==== Construct Parameters ==== #
        queueName = requestInfo.queueName
        reqOptions = XSS::Converter::CoreConverter.getRequestOptions(requestInfo.thriftRequestOptions)
        reqOptions.merge! XSS::Converter::CoreConverter::getOperationContextOptions(requestInfo.thriftOperationContext)
        reqOptions[:metadata] = metadata unless metadata.nil?
        LoggingAspect::logger.info("Creating queue #{queueName}")
        LoggingAspect::logger.debug("'options' is #{reqOptions.to_s}")
        result = queueClient.create_queue(queueName, reqOptions)
        # ==== Construct Return Value ==== #
        LoggingAspect::logger.info("Creating queue #{queueName} successful")
        result = XSS::AutoGenerated::CreateQueueResponse.new
        result.created = true # successfully created at this point.
        result.response = XSS::Converter::QueueConverter::buildCloudQueueResponseFromInternalRequestInfoAndQueueName(internalRequestInfo, queueName)
        result
      end

      def deleteQueue(requestInfo, accountInfo, deleteIfExists)
        # If queue does not exist, return success
        if deleteIfExists
          exists = self.exists(requestInfo, accountInfo)
          unless (exists.exists)
            return true
          end
        end
        # ==== Build Client ==== #
        internalRequestInfo = XSS::Utilities::get_default_request_info
        queueClient = self.build_client(internalRequestInfo, accountInfo, XSS::Converter::QueueConverter.getQueueService)
        # ==== Construct Parameters ==== #
        queueName = requestInfo.queueName
        reqOptions = XSS::Converter::CoreConverter.getRequestOptions(requestInfo.thriftRequestOptions)
        reqOptions.merge! XSS::Converter::CoreConverter::getOperationContextOptions(requestInfo.thriftOperationContext)
        LoggingAspect::logger.info("Deleting queue #{queueName}")
        LoggingAspect::logger.debug("'options' is #{reqOptions.to_s}")
        result = queueClient.delete_queue(queueName, reqOptions)
        # ==== Construct Return Value ==== #
        LoggingAspect::logger.info("Deleting queue #{queueName} successful")
        # ==== Construct Return Value ==== #
        true # successfully deleted at this point.
      end

      def exists(requestInfo, accountInfo)
        # ==== Build Client ==== #
        internalRequestInfo = XSS::Utilities::get_default_request_info
        queueClient = self.build_client(internalRequestInfo, accountInfo, XSS::Converter::QueueConverter.getQueueService)
        # ==== Construct Parameters ==== #
        queueName = requestInfo.queueName
        reqOptions = XSS::Converter::CoreConverter.getRequestOptions(requestInfo.thriftRequestOptions)
        reqOptions.merge! XSS::Converter::CoreConverter::getOperationContextOptions(requestInfo.thriftOperationContext)
        reqOptions[:prefix] = queueName
        # ==== Operation ==== #
        LoggingAspect::logger.info("Trying to get if queue #{queueName} exists")
        LoggingAspect::logger.debug("'options' is #{reqOptions.to_s}")
        temp = queueClient.list_queues(reqOptions)

        # ==== Construct Return Value ==== #
        LoggingAspect::logger.info("Trying to get if queue #{queueName} exists successful")
        result = XSS::AutoGenerated::QueueExistsResponse.new
        result.exists = (!temp.empty?) && (temp.detect { |queue| queue.name == queueName })
        result.response = XSS::Converter::QueueConverter::buildCloudQueueResponseFromInternalRequestInfoAndQueueName(internalRequestInfo, queueName)
        result
      end

      def clearMessages(requestInfo, accountInfo)
        # ==== Build Client ==== #
        internalRequestInfo = XSS::Utilities::get_default_request_info
        queueClient = self.build_client(internalRequestInfo, accountInfo, XSS::Converter::QueueConverter.getQueueService)
        # ==== Construct Parameters ==== #
        queueName = requestInfo.queueName
        reqOptions = XSS::Converter::CoreConverter.getRequestOptions(requestInfo.thriftRequestOptions)
        reqOptions.merge! XSS::Converter::CoreConverter::getOperationContextOptions(requestInfo.thriftOperationContext)

        # ==== Operation ==== #
        # retry?
        LoggingAspect::logger.info("Clearing messages for queue #{queueName}")
        LoggingAspect::logger.debug("'options' is #{reqOptions.to_s}")
        temp = queueClient.clear_messages(queueName, reqOptions)
        LoggingAspect::logger.info("Clearing messages for queue #{queueName} successful")
        # ==== Construct Return Value ==== #
        nil
      end

      def fetchAttributes(requestInfo, accountInfo)
        # ==== Build Client ==== #
        internalRequestInfo = XSS::Utilities::get_default_request_info
        queueClient = self.build_client(internalRequestInfo, accountInfo, XSS::Converter::QueueConverter.getQueueService)
        # ==== Construct Parameters ==== #
        queueName = requestInfo.queueName
        reqOptions = XSS::Converter::CoreConverter.getRequestOptions(requestInfo.thriftRequestOptions)
        reqOptions.merge! XSS::Converter::CoreConverter::getOperationContextOptions(requestInfo.thriftOperationContext)

        # ==== Operation ==== #
        LoggingAspect::logger.info("Fetching attributes for queue #{queueName}")
        LoggingAspect::logger.debug("'options' is #{reqOptions.to_s}")
        temp = queueClient.get_queue_metadata(queueName, reqOptions)

        # ==== Construct Return Value ==== #
        LoggingAspect::logger.info("Fetching attributes for queue #{queueName} successful")
        result.response = XSS::Converter::QueueConverter::buildCloudQueueResponseFromInternalRequestInfoAndQueueName(internalRequestInfo, queueName)
        result.metadata = temp[1]
        result.ApproximateMessageCount = temp[0]
        result
      end

      def setMetadata(requestInfo, accountInfo, metadata)
        # ==== Build Client ==== #
        internalRequestInfo = XSS::Utilities::get_default_request_info
        queueClient = self.build_client(internalRequestInfo, accountInfo, XSS::Converter::QueueConverter.getQueueService)
        # ==== Construct Parameters ==== #
        queueName = requestInfo.queueName
        reqOptions = XSS::Converter::CoreConverter.getRequestOptions(requestInfo.thriftRequestOptions)
        reqOptions.merge! XSS::Converter::CoreConverter::getOperationContextOptions(requestInfo.thriftOperationContext)

        # ==== Operation ==== #
        LoggingAspect::logger.info("Setting metadata for queue #{queueName}")
        LoggingAspect::logger.debug("'options' is #{reqOptions.to_s}")
        LoggingAspect::logger.debug("'metadata' is #{metadata.to_s}")
        temp = queueClient.set_queue_metadata(queueName, metadata, reqOptions)

        # ==== Construct Return Value ==== #
        LoggingAspect::logger.info("Setting metadata for queue #{queueName} successful")
        nil
      end

      def addMessage(addMessagePayload, accountInfo)
        # ==== Build Client ==== #
        internalRequestInfo = XSS::Utilities::get_default_request_info
        queueClient = self.build_client(internalRequestInfo, accountInfo, XSS::Converter::QueueConverter.getQueueService)
        # ==== Construct Parameters ==== #
        requestInfo = addMessagePayload.requestInfo
        queueName = requestInfo.queueName
        reqOptions = XSS::Converter::CoreConverter.getRequestOptions(requestInfo.thriftRequestOptions)
        reqOptions.merge! XSS::Converter::CoreConverter::getOperationContextOptions(requestInfo.thriftOperationContext)
        messageText = addMessagePayload.payload
        reqOptions[:visibility_timeout] = XSS::Utilities::timeSpanToSecond(addMessagePayload.initialVisibilityDelay) unless addMessagePayload.initialVisibilityDelay < 0
        reqOptions[:message_ttl] = XSS::Utilities::timeSpanToSecond(addMessagePayload.timeToLive)  unless addMessagePayload.timeToLive < 0
        reqOptions[:encode] = true #encode message text

        # ==== Operation ==== #
        LoggingAspect::logger.info("Creating message in queue #{queueName}")
        LoggingAspect::logger.debug("'options' is #{reqOptions.to_s}")
        LoggingAspect::logger.debug("'messageText' is #{messageText}")
        temp = queueClient.create_message(queueName, messageText, reqOptions)

        # ==== Construct Return Value ==== #
        LoggingAspect::logger.info("Creating message in queue #{queueName} successful")
        result = XSS::AutoGenerated::CreateMessageResponse.new
        unless temp.empty?
          result.messageId = temp[0].id
          result.popReceipt = temp[0].pop_receipt
          result.insertionTime = XSS::Utilities::timeStringToInteger(temp[0].insertion_time)
          result.expirationTime = XSS::Utilities::timeStringToInteger(temp[0].expiration_time)
          result.nextVisibleTime = XSS::Utilities::timeStringToInteger(temp[0].time_next_visible)
        end
        result
      end

      def updateMessage(updateMessagePayload, accountInfo, visibilityTimeout, updateFields)
        # ==== Build Client ==== #
        internalRequestInfo = XSS::Utilities::get_default_request_info
        queueClient = self.build_client(internalRequestInfo, accountInfo, XSS::Converter::QueueConverter.getQueueService)
        # ==== Construct Parameters ==== #
        requestInfo = updateMessagePayload.requestInfo
        queueName = requestInfo.queueName
        reqOptions = XSS::Converter::CoreConverter.getRequestOptions(requestInfo.thriftRequestOptions)
        reqOptions.merge! XSS::Converter::CoreConverter::getOperationContextOptions(requestInfo.thriftOperationContext)
        reqOptions[:encode] = true #encode message text
        messageId = updateMessagePayload.messageId
        popReceipt = updateMessagePayload.popReceipt
        messageText = updateMessagePayload.content
        visibilityTimeout = visibilityTimeout

        # ==== Operation ==== #
        LoggingAspect::logger.info("Updating message in queue #{queueName}")
        LoggingAspect::logger.debug("'options' is #{reqOptions.to_s}")
        LoggingAspect::logger.debug("'messageText' is #{messageText}")
        LoggingAspect::logger.debug("'popReceipt' is #{popReceipt}")
        LoggingAspect::logger.debug("'visibilityTimeout' is #{visibilityTimeout}")
        temp = queueClient.update_message(queueName, messageId, popReceipt, messageText, visibilityTimeout, reqOptions)

        # ==== Construct Return Value ==== #
        LoggingAspect::logger.info("Updating message in queue #{queueName} successful")
        result = XSS::AutoGenerated::UpdateMessageResponse.new
        result.popReceipt = temp[0]
        result.nextVisibleTime = XSS::Utilities::timeStringToInteger(temp[1])
        result
      end

      def getMessage(requestInfo, accountInfo, visibilityTimeout)
        # ==== Build Client ==== #
        internalRequestInfo = XSS::Utilities::get_default_request_info
        queueClient = self.build_client(internalRequestInfo, accountInfo, XSS::Converter::QueueConverter.getQueueService)
        # ==== Construct Parameters ==== #
        queueName = requestInfo.queueName
        visibilityTimeout = visibilityTimeout < 0 ? 0 : visibilityTimeout
        reqOptions = XSS::Converter::CoreConverter.getRequestOptions(requestInfo.thriftRequestOptions)
        reqOptions.merge! XSS::Converter::CoreConverter::getOperationContextOptions(requestInfo.thriftOperationContext)

        # ==== Operation ==== #
        LoggingAspect::logger.info("Getting message from queue #{queueName}")
        LoggingAspect::logger.debug("'options' is #{reqOptions.to_s}")
        LoggingAspect::logger.debug("'visibilityTimeout' is #{visibilityTimeout.to_s}")
        temp = queueClient.list_messages(queueName, visibilityTimeout, reqOptions)

        # ==== Construct Return Value ==== #
        LoggingAspect::logger.info("Getting message from queue #{queueName} successful")
        result = XSS::Converter::QueueConverter.convertQueueMessageToThriftQueueMessage(temp[0])
        result
      end

      def peekMessage(requestInfo, accountInfo)
        # ==== Build Client ==== #
        internalRequestInfo = XSS::Utilities::get_default_request_info
        queueClient = self.build_client(internalRequestInfo, accountInfo, XSS::Converter::QueueConverter.getQueueService)
        # ==== Construct Parameters ==== #
        queueName = requestInfo.queueName
        reqOptions = XSS::Converter::CoreConverter.getRequestOptions(requestInfo.thriftRequestOptions)
        reqOptions.merge! XSS::Converter::CoreConverter::getOperationContextOptions(requestInfo.thriftOperationContext)

        # ==== Operation ==== #
        LoggingAspect::logger.info("Peeking message from queue #{queueName}")
        LoggingAspect::logger.debug("'options' is #{reqOptions.to_s}")
        temp = queueClient.peek_messages(queueName, reqOptions)

        # ==== Construct Return Value ==== #
        LoggingAspect::logger.info("Peeking message from queue #{queueName} successful")
        result = QueueConverter.convertQueueMessageToThriftQueueMessage(temp[0])
        return result
      end

      def getMessages(requestInfo, accountInfo, visibilityTimeout, messageCount)
        # ==== Build Client ==== #
        internalRequestInfo = XSS::Utilities::get_default_request_info
        queueClient = self.build_client(internalRequestInfo, accountInfo, XSS::Converter::QueueConverter.getQueueService)
        # ==== Construct Parameters ==== #
        queueName = requestInfo.queueName
        visibilityTimeout = visibilityTimeout < 0 ? 0 : visibilityTimeout
        reqOptions = XSS::Converter::CoreConverter.getRequestOptions(requestInfo.thriftRequestOptions)
        reqOptions.merge! XSS::Converter::CoreConverter::getOperationContextOptions(requestInfo.thriftOperationContext)
        reqOptions[:number_of_messages] = messageCount

        # ==== Operation ==== #
        temp = queueClient.list_messages(queueName, visibilityTimeout, reqOptions)

        # ==== Construct Return Value ==== #
        result = []
        temp.each do |message|
          entry = QueueConverter.convertQueueMessageToThriftQueueMessage(message)
          result.push(entry)
        end
        return result
      end

      def peekMessages(requestInfo, accountInfo, messageCount)
        # ==== Build Client ==== #
        internalRequestInfo = XSS::Utilities::get_default_request_info
        queueClient = self.build_client(internalRequestInfo, accountInfo, XSS::Converter::QueueConverter.getQueueService)
        # ==== Construct Parameters ==== #
        queueName = requestInfo.queueName
        reqOptions = XSS::Converter::CoreConverter.getRequestOptions(requestInfo.thriftRequestOptions)
        reqOptions.merge! XSS::Converter::CoreConverter::getOperationContextOptions(requestInfo.thriftOperationContext)
        reqOptions[:number_of_messages] = messageCount

        # ==== Operation ==== #
        temp = queueClient.peek_messages(queueName, reqOptions)

        # ==== Construct Return Value ==== #
        result = []
        temp.each do |message|
          entry = QueueConverter.convertQueueMessageToThriftQueueMessage(message)
          result.push(entry)
        end
        return result
      end

      def deleteMessage(requestInfo, accountInfo, messageId, popReceipt)
        # ==== Build Client ==== #
        internalRequestInfo = XSS::Utilities::get_default_request_info
        queueClient = self.build_client(internalRequestInfo, accountInfo, XSS::Converter::QueueConverter.getQueueService)
        # ==== Construct Parameters ==== #
        queueName = requestInfo.queueName
        messageId = messageId
        popReceipt = popReceipt
        reqOptions = XSS::Converter::CoreConverter.getRequestOptions(requestInfo.thriftRequestOptions)
        reqOptions.merge! XSS::Converter::CoreConverter::getOperationContextOptions(requestInfo.thriftOperationContext)

        # ==== Operation ==== #
        queueClient.delete_message(queueName, messageId, popReceipt, reqOptions)

        # ==== Construct Return Value ==== #
        return
      end

      def setPermissions(requestInfo, accountInfo, permissions)
        # ==== Build Client ==== #
        internalRequestInfo = XSS::Utilities::get_default_request_info
        queueClient = self.build_client(internalRequestInfo, accountInfo, XSS::Converter::QueueConverter.getQueueService)
        # ==== Construct Parameters ==== #
        queueName = requestInfo.queueName
        reqOptions = XSS::Converter::CoreConverter.getRequestOptions(requestInfo.thriftRequestOptions)
        reqOptions.merge! XSS::Converter::CoreConverter::getOperationContextOptions(requestInfo.thriftOperationContext)
        signedIdentifiers = []
        permissions.each do |permission|
          signedIdentifier = XSS::Service::SignedIdentifier.new
          signedIdentifier.access_policy.expiry = XSS::Utilities::timeStampToTime(permissions[permission].expiryTime)
          signedIdentifier.access_policy.permission = permissions[permission].permissions
          signedIdentifier.access_policy.start = XSS::Utilities::timeStampToTime(permissions[permission].startTime)
          signedIdentifier.id = permission
          signedIdentifiers.push(signedIdentifier)
        end
        reqOptions[:signed_identifiers] = signedIdentifiers

        # ==== Operation ==== #
        queueClient.set_queue_acl(queueName, reqOptions)

        # ==== Construct Return Value ==== #
        return
      end

      def getPermissions(requestInfo, accountInfo)
        # ==== Build Client ==== #
        internalRequestInfo = XSS::Utilities::get_default_request_info
        queueClient = self.build_client(internalRequestInfo, accountInfo, XSS::Converter::QueueConverter.getQueueService)
        # ==== Construct Parameters ==== #
        queueName = requestInfo.queueName
        reqOptions = XSS::Converter::CoreConverter.getRequestOptions(requestInfo.thriftRequestOptions)
        reqOptions.merge! XSS::Converter::CoreConverter::getOperationContextOptions(requestInfo.thriftOperationContext)

        # ==== Operation ==== #
        temp = queueClient.get_queue_acl(queueName, reqOptions)

        # ==== Construct Return Value ==== #
        result = {}
        temp.each do |signedIdentifier|
          key = signedIdentifier.id
          policy = signedIdentifier.access_policy
          value = XSS::AutoGenerated::ThriftSharedAccessQueuePolicy.new
          value.permissions = policy.permission
          value.expiryTime = XSS::Utilities::timeStringToInteger(policy.expiry)
          value.startTime = XSS::Utilities::timeStringToInteger(policy.start)
          result[key] = value
        end
        return result
      end
    end
  end
end
