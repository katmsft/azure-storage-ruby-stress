require_relative "base_handler"
require_relative "../utils"
require_relative "../auto_generated/cloud_table_service"
require_relative "../converter/core_converter"
require_relative "../converter/table_converter"
require_relative "../infrastructure/logging_aspect"


module Azure::Storage::Stress
  module Handler
    class CloudTableHandler < BaseHandler
      def create(createIfNotExists, requestInfo, accountInfo)
        tableClient = XSS::Converter::TableConverter.getTableService(self, accountInfo)

        # ==== Construct Parameters ==== #
        tableName = requestInfo.tableName
        reqOptions = XSS::Converter::CoreConverter.getRequestOptions(requestInfo.thriftRequestOptions)
        reqOptions.merge! XSS::Converter::CoreConverter::getOperationContextOptions(requestInfo.thriftOperationContext)

        # ==== Operation ==== #
        temp = nil
        exception = nil
        begin
          if createIfNotExists
            exist = false
            begin
              tableClient.get_table(tableName, reqOptions)
              exist = true
            rescue Azure::Core::Http::HTTPError => e
              exception = e if e.status_code != 404 || e.type != "ResourceNotFound"
            end

            temp =
              if exist
                LoggingAspect::logger.info("Table #{tableName} exists when creating")
                nil
              else
                LoggingAspect::logger.info("Create table: #{tableName}")
                tableClient.create_table(tableName, reqOptions)
              end
          else
            LoggingAspect::logger.info("Create table: #{tableName}")
            temp = tableClient.create_table(tableName, reqOptions)
          end
        rescue => e
          exception = e
        end

        # ==== Construct Return Value ==== #
        result = XSS::AutoGenerated::CloudTableService::Create_result.new
        result.success = temp.nil?
        result.storageException = exception
        result
      end

      def exists(requestInfo, accountInfo)
        tableClient = XSS::Converter::TableConverter.getTableService(self, accountInfo)
        
        # ==== Construct Parameters ==== #
        tableName = requestInfo.tableName
        reqOptions = XSS::Converter::CoreConverter.getRequestOptions(requestInfo.thriftRequestOptions)
        reqOptions.merge! XSS::Converter::CoreConverter::getOperationContextOptions(requestInfo.thriftOperationContext)

        # ==== Operation ==== #
        LoggingAspect::logger.info("Get table (exists?): #{tableName}")
        exist = false
        exception = nil
        begin
          tableClient.get_table(tableName, reqOptions)
          exist = true
        rescue Azure::Core::Http::HTTPError => e
          exception = e if e.status_code != 404 || e.type != "ResourceNotFound"
        end

        # ==== Construct Return Value ==== #
        result = XSS::AutoGenerated::CloudTableService::Exists_result.new
        result.success = exist
        result.storageException = exception
        result
      end

      def deleteTable(deleteIfExists, requestInfo, accountInfo)
        tableClient = XSS::Converter::TableConverter.getTableService(self, accountInfo)
        
        # ==== Construct Parameters ==== #
        tableName = requestInfo.tableName
        reqOptions = XSS::Converter::CoreConverter.getRequestOptions(requestInfo.thriftRequestOptions)
        reqOptions.merge! XSS::Converter::CoreConverter::getOperationContextOptions(requestInfo.thriftOperationContext)

        # ==== Operation ==== #
        exception = nil
        begin
          if deleteIfExists
            exist = false
            begin
              tableClient.get_table(tableName, reqOptions)
              exist = true
            rescue Azure::Core::Http::HTTPError => e
              exception = e if e.status_code != 404 || e.type != "ResourceNotFound"
            end

            temp =
              unless exist
                LoggingAspect::logger.info("Table #{tableName} doesn't exist when deleting")
                nil
              else
                LoggingAspect::logger.info("Delete table: #{tableName}")
                temp = tableClient.delete_table(tableName, reqOptions)
              end
          else
            LoggingAspect::logger.info("Delete table: #{tableName}")
            temp = tableClient.delete_table(tableName, reqOptions)
          end
        rescue => e
          exception = e
        end

        # ==== Construct Return Value ==== #
        result = XSS::AutoGenerated::CloudTableService::DeleteTable_result.new
        result.success = temp.nil?
        result.storageException = exception
        result
      end

      def setPermissions(reqInfo, accountInfo, permissions)
        tableClient = XSS::Converter::TableConverter.getTableService(self, accountInfo)

        # ==== Construct Parameters ==== #
        tableName = requestInfo.tableName
        reqOptions = XSS::Converter::CoreConverter.getRequestOptions(requestInfo.thriftRequestOptions)
        reqOptions.merge! XSS::Converter::CoreConverter::getOperationContextOptions(requestInfo.thriftOperationContext)
        reqOptions[:signed_identifiers] = XSS::Converter::CoreConverter.getSignedIdentifiersFromThriftSharedAccessPolicies(permissions)

        # ==== Operation ==== #
        exception = nil
        begin
          LoggingAspect::logger.info("Set table ACL: #{tableName}")
          LoggingAspect::logger.debug("'options' is #{reqOptions.to_s}")
          tableClient.set_table_acl(tableName, reqOptions)
        rescue => e
          exception = e
        end

        # ==== Construct Return Value ==== #
        result = XSS::AutoGenerated::CloudTableService::SetPermissions_result.new
        result.storageException = exception
        result
      end

      def getPermissions(reqInfo, accountInfo)
        tableClient = XSS::Converter::TableConverter.getTableService(self, accountInfo)

        # ==== Construct Parameters ==== #
        tableName = requestInfo.tableName
        reqOptions = XSS::Converter::CoreConverter.getRequestOptions(requestInfo.thriftRequestOptions)
        reqOptions.merge! XSS::Converter::CoreConverter::getOperationContextOptions(requestInfo.thriftOperationContext)

        # ==== Operation ==== #
        LoggingAspect::logger.info("Get table ACL: #{tableName}")
        exception = nil
        begin
          temp = tableClient.get_table_acl(tableName, reqOptions)
        rescue => e
          exception = e
        end

        # ==== Construct Return Value ==== #
        result = XSS::AutoGenerated::CloudTableService::GetPermissions_result.new
        result.storageException = exception
        result.success = XSS::Converter::CoreConverter::getThriftSharedAccessPoliciesFromSignedIdentifiers(temp, XSS::AutoGenerated::ThriftSharedAccessTablePolicy)
        result
      end

      def Execute(operation, requestInfo, accountInfo)
        tableClient = XSS::Converter::TableConverter.getTableService(self, accountInfo)

        # ==== Construct Parameters ==== #
        tableName = requestInfo.tableName
        entity = XSS::Converter::TableConverter.getStorageEntityFromThriftOperation(operation)
        reqOptions = XSS::Converter::CoreConverter.getRequestOptions(requestInfo.thriftRequestOptions)
        reqOptions.merge! XSS::Converter::CoreConverter::getOperationContextOptions(requestInfo.thriftOperationContext)

        # ==== Operation ==== #
        temp = nil
        result = XSS::AutoGenerated::CloudTableService::Execute_result.new
        LoggingAspect::logger.info("Execute  #{operation.operationType.to_s} on table #{tableName}")
        LoggingAspect::logger.debug("entity is: #{entity.inspect} options is #{reqOptions.to_s}")
        case operation.operationType
        when Insert
          begin
            temp = tableClient.insert_entity(tableName, entity, reqOptions)
            result.success = XSS::AutoGenerated::ThriftTableResul.new
            result.success.httpStatusCode = 200
            result.success.etag = temp.etag
          rescue => e
            result.wse = e
          end
        when Delete
          begin
            temp = tableClient.delete_entity(tableName, entity[:PartitionKey], entity[:RowKey], reqOptions)
            result.success = XSS::AutoGenerated::ThriftTableResul.new
            result.success.httpStatusCode = 200
          rescue => each
            result.wse = e
          end
        when Replace
          begin
            temp = tableClient.update_entity(tableName, entity, reqOptions)
            result.success = XSS::AutoGenerated::ThriftTableResul.new
            result.success.httpStatusCode = 200
            result.success.etag = temp
          rescue => e
            result.wse = e
          end
        when Merge
          begin
            temp = tableClient.merge_entity(tableName, entity, reqOptions)
            
            result.success.httpStatusCode = 200
            result.success.etag = temp
          rescue => e
            result.wse = e
          end
        when InsertOrReplace
          begin
            temp = tableClient.insert_or_replace_entity(tableName, entity, reqOptions)
            result.success = XSS::AutoGenerated::ThriftTableResul.new
            result.success.httpStatusCode = 200
            result.success.etag = temp
          rescue => e
            result.wse = e
          end
        when InsertOrMerge
          begin
            temp = tableClient.insert_or_merge_entity(tableName, entity, reqOptions)
            result.success = XSS::AutoGenerated::ThriftTableResul.new
            result.success.httpStatusCode = 200
            result.success.etag = temp
          rescue => e
            result.wse = e
          end
        when Retrieve
          begin
            temp = tableClient.get_entity(tableName, entity[:PartitionKey], entity[:RowKey], reqOptions)
            result.success = XSS::AutoGenerated::ThriftTableResul.new
            result.success.entity = XSS::Converter::TableConverter.getThriftEntityFromStorageEntity(temp)
            result.success.httpStatusCode = 200
            result.success.etag = result.success.entity.etag
          rescue => e
            result.wse = e
          end
        end

        # ==== Construct Return Value ==== #
        result
      end

      def ExecuteBatch(operations, requestInfo, accountInfo)
        tableClient = XSS::Converter::TableConverter.getTableService(self, accountInfo)

        # ==== Construct Parameters ==== #
        tableName = requestInfo.tableName
        batch = XSS::Converter::TableConverter.getStorageBatchFromThriftOperations(operations)
        reqOptions = XSS::Converter::CoreConverter.getRequestOptions(requestInfo.thriftRequestOptions)
        reqOptions.merge! XSS::Converter::CoreConverter::getOperationContextOptions(requestInfo.thriftOperationContext)

        # ==== Operation ==== #
        LoggingAspect::logger.info("Execute batch on table #{tableName}")
        LoggingAspect::logger.debug("options is #{reqOptions.to_s}")
        temp = nil
        result = XSS::AutoGenerated::CloudTableService::ExecuteBatch_result.new
        begin
          temp = tableClient.execute_batch(batch, reqOptions)
        rescue => e
          result.wse = e
          return result
        end

        # ==== Construct Return Value ==== #
        result.success = []
        temp.each do |response|
          opResult = XSS::AutoGenerated::ThriftTableResul.new
          opResult.etag = 
            if response.nil?
              nil
            elsif response.is_a?(Azure::Storage::Table::Entity)
              opResult.entity = response
              response.etag
            else
              response
            end
          result.success.httpStatusCode = 200
          result.success.push(opResult)
        end
        result
      end

      def ExecuteQuery(tableQuery, requestInfo, accountInfo)
        tableClient = XSS::Converter::TableConverter.getTableService(self, accountInfo)

        # ==== Construct Parameters ==== #
        tableName = requestInfo.tableName
        query = XSS::Converter::TableConverter.getStorageQueryFromThriftQuery(tableQuery)
        reqOptions = XSS::Converter::CoreConverter.getRequestOptions(requestInfo.thriftRequestOptions)
        reqOptions.merge! XSS::Converter::CoreConverter::getOperationContextOptions(requestInfo.thriftOperationContext)
        reqOptions.merge! query

        # ==== Operation ==== #
        LoggingAspect::logger.info("Execute query on table #{tableName}")
        LoggingAspect::logger.debug("options is #{reqOptions.to_s}")
        temp = nil
        result = XSS::AutoGenerated::CloudTableService::ExecuteQuery_result.new
        result.success = []
        begin
          begin
            temp = nil
            temp = tableClient.query_entities(tableName, reqOptions)
          rescue => e
            result.wse = e
          end

          unless temp.nil?
            temp.each do |entity|
              thriftEntity = XSS::Converter::TableConverter.getThriftEntityFromStorageEntity(entity)
              result.success.push(thriftEntity)
            end
          end
        end while !temp.nil? && !temp.continuation_token.nil?

        # ==== Construct Return Value ==== #
        result
      end

      def ExecuteQuerySegment(tableQuery, continuationToken, requestInfo, accountInfo)
        tableClient = XSS::Converter::TableConverter.getTableService(self, accountInfo)

        # ==== Construct Parameters ==== #
        tableName = requestInfo.tableName
        query = XSS::Converter::TableConverter.getStorageQueryFromThriftQuery(tableQuery, continuationToken)
        reqOptions = XSS::Converter::CoreConverter.getRequestOptions(requestInfo.thriftRequestOptions)
        reqOptions.merge! XSS::Converter::CoreConverter::getOperationContextOptions(requestInfo.thriftOperationContext)
        reqOptions.merge! query

        # ==== Operation ==== #
        LoggingAspect::logger.info("Execute query segmented on table #{tableName}")
        LoggingAspect::logger.debug("options is #{reqOptions.to_s}")
        temp = nil
        result = XSS::AutoGenerated::CloudTableService::ExecuteQuerySegment_result.new
        begin
          temp = tableClient.query_entities(tableName, reqOptions)
        rescue => e
          result.wse = e
          return result
        end

        # ==== Construct Return Value ==== #
        unless temp.continuation_token.nil?
          result.continuationToken = XSS::AutoGenerated::ThriftTableContinuationToken.new
          result.continuationToken.nextPartitionKey = temp.continuation_token[:next_partition_key]
          result.continuationToken.nextRowKey = temp.continuation_token[:next_row_key]
        end

        result.success = []
        temp.each do |entity|
          thriftEntity = XSS::Converter::TableConverter.getThriftEntityFromStorageEntity(entity)
          result.success.push(thriftEntity)
        end
        result
      end
    end
  end
end
